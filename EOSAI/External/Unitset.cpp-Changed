
#include "stdafx.h"

#include "BuildOption.h"
#include "Unitset.h"
#include "UnitTemplate.h"
#include "City.h"
#include "Airfield.h"
#include "ResourceSource.h"
#include "BuildingDescription.h"
#include "BitmapManager.h"
#include "TWDx.h"
#include "BCString.h"
#include "TechnologyDesc.h"
#include "TechTreeNode.h"
#include "WarningDialog.h"

#include "WorldDescServer.h"
#include "WorldDescPlayer.h"
#include "WorldDescPlayerProxy.h"

#include "GameAppState.h"

#include "StringDataBlock.h"
#include "ApplicationVersion.h"
#include "Checkpoint.h"

#include "HeaderInformationForFile.h"
#include "LocalSMUFiles.h"
#include "CompoundAnimationDesc.h"
#include "SimpleAnimationDesc.h"
#include "Player.h"
#include "BCFile.h"
#include "BCXMLReader.h"
#include "BCStopwatch2.h"
#include "Encrypter.h"
#include "AnalysisUnitTemplateList.h"
#include "UnitTemplateImage.h"
#include "UnitCategory.h"

#include "mmsystem.h"
#include "CombatManager.h"
#include "ProgressDialog.h"
#include "AirfieldImprovement.h"
#include "SplashDialog.h"
#include "MathFunction.h"
#include "UnitTemplateB.h"
extern CSplashDialog* g_pSplashDialog;

#include <direct.h>
#include <sys/types.h>
#include <sys/stat.h>

const long UNITSET_VALIDATION_KEY = 1821987124;

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#include "ResourceEffectsSummary.h"


//
std::list< CUnitsetBriefDesc* >  CUnitset::s_AvailableUnitsets;

//
CString CUnitsetBriefDesc::GetTitle()
{
	if( m_strLocalFile != _T("") ){ return CBCString::GetEverythingBefore( m_strLocalFile, _T(".") ); }
	if( m_strFileId != _T("") ){ return CBCString::GetEverythingBefore( m_strFileId, _T(".") ); }
	ASSERT( false );
	return _T("");
}

CString CUnitsetBriefDesc::GetAuthor()
{
	CString strAuthor;
	//CBCFile::DissectFile( m_strFileId, NULL, &strAuthor, NULL, NULL );
	if( m_strLocalFile != _T("") ){ CBCFile::DissectFile( m_strLocalFile, NULL, &strAuthor, NULL, NULL ); }
	if( m_strFileId != _T("") ){ CBCFile::DissectFile( m_strFileId, NULL, &strAuthor, NULL, NULL ); }
	return strAuthor;
}

/*
void  CItemAndUnitsubset::AddUnitsubset( CString strUnitsubset )
{
	if( UnitsubsetAdded( strUnitsubset ) ) return;

	if( m_bListContainsPositiveItems )
	{
		m_Unitsubsets.AddTail( strUnitsubset );
	}
	else
	{
		POSITION pos = m_Unitsubsets.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CString strUnitsubsetInList = m_Unitsubsets.GetNext( pos );
			if( strUnitsubsetInList == strUnitsubset )
			{
				m_Unitsubsets.RemoveAt( prevPos );
			}
		}
	}
}

void  CItemAndUnitsubset::RemoveUnitsubset( CString strUnitsubset )
{
	if( UnitsubsetAdded( strUnitsubset ) == false ) return;

	if( m_bListContainsPositiveItems )
	{
		POSITION pos = m_Unitsubsets.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CString strUnitsubsetInList = m_Unitsubsets.GetNext( pos );
			if( strUnitsubsetInList == strUnitsubset )
			{
				m_Unitsubsets.RemoveAt( prevPos );
			}
		}
	}
	else
	{
		m_Unitsubsets.AddTail( strUnitsubset );
	}
}
*/
/*
void  CItemAndUnitsubset::SetUnitsubsetToPositive( CString strUnitsubset )
{
	if( UnitsubsetIsPositive( strUnitsubset ) ) return;

	if( m_bListContainsPositiveItems )
	{
		m_Unitsubsets.AddTail( strUnitsubset );
	}
	else
	{
		POSITION pos = m_Unitsubsets.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CString strUnitsubsetInList = m_Unitsubsets.GetNext( pos );
			if( strUnitsubsetInList == strUnitsubset )
			{
				m_Unitsubsets.RemoveAt( prevPos );
			}
		}
	}
}

void  CItemAndUnitsubset::SetUnitsubsetToNegative( CString strUnitsubset )
{
	if( UnitsubsetIsPositive( strUnitsubset ) == false ) return;

	if( m_bListContainsPositiveItems )
	{
		POSITION pos = m_Unitsubsets.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CString strUnitsubsetInList = m_Unitsubsets.GetNext( pos );
			if( strUnitsubsetInList == strUnitsubset )
			{
				m_Unitsubsets.RemoveAt( prevPos );
			}
		}
	}
	else
	{
		m_Unitsubsets.AddTail( strUnitsubset );
	}
}
*/
/*
bool CItemAndUnitsubset::UnitsubsetAdded( CString strUnitsubset )
{
	POSITION pos = m_Unitsubsets.GetHeadPosition();
	while( pos )
	{
		CString strUnitsubsetInList = m_Unitsubsets.GetNext( pos );
		if( strUnitsubsetInList == strUnitsubset )
		{
			return m_bListContainsPositiveItems;
		}
	}
	return !m_bListContainsPositiveItems;
}
*/
/*
bool CItemAndUnitsubset::UnitsubsetIsPositive( CString strUnitsubset )
{
	POSITION pos = m_Unitsubsets.GetHeadPosition();
	while( pos )
	{
		CString strUnitsubsetInList = m_Unitsubsets.GetNext( pos );
		if( strUnitsubsetInList == strUnitsubset )
		{
			return m_bListContainsPositiveItems;
		}
	}
	return !m_bListContainsPositiveItems;
}

void CItemAndUnitsubset::ToggleState( CString strUnitsubset )
{
	if( UnitsubsetIsPositive( strUnitsubset ) ){ SetUnitsubsetToNegative( strUnitsubset ); }
	else{ SetUnitsubsetToPositive( strUnitsubset ); }
}

void CItemAndUnitsubset::SwitchPositiveNegative()
{
	bool bOldState = m_bListContainsPositiveItems;

	POSITION pos = m_pUnitset->GetUnitsubsetList()->GetHeadPosition();
	while( pos )
	{
		CString strUnitsubset = m_pUnitset->GetUnitsubsetList()->GetNext( pos );
		if( UnitsubsetIsPositive( strUnitsubset ) )
		{
			m_bListContainsPositiveItems = !bOldState;
			SetUnitsubsetToPositive( strUnitsubset );
			m_bListContainsPositiveItems = bOldState;
		}
		else
		{
			m_bListContainsPositiveItems = !bOldState;
			SetUnitsubsetToNegative( strUnitsubset );
			m_bListContainsPositiveItems = bOldState;
		}
	}
	m_bListContainsPositiveItems = !bOldState;
}

long  CItemAndUnitsubset::GetNumberOfPositiveUnitsubsets()
{
	long iCount = 0;
	POSITION pos = m_pUnitset->GetUnitsubsetList()->GetHeadPosition();
	while( pos )
	{
		CString strUnitsubset = m_pUnitset->GetUnitsubsetList()->GetNext( pos );
		if( UnitsubsetIsPositive( strUnitsubset ) )
		{
			iCount++;
		}
	}
	return iCount;
	/*
	if( m_bListContainsPositiveItems )
	{
		return (long) m_Unitsubsets.GetCount();
	}
	else
	{
		long iCount = 0;
		POSITION pos = m_pUnitset->GetUnitsubsetList()->GetHeadPosition();
		while( pos )
		{
			CString strUnitsubset = m_pUnitset->GetUnitsubsetList()->GetNext( pos );
			if( UnitsubsetIsPositive( strUnitsubset ) == false )
			{
				iCount++;
			}
		}
		return iCount;
	}
	*-/
}

bool  CItemAndUnitsubset::AllUnitsubsetsArePositive()
{
	return GetNumberOfPositiveUnitsubsets() == m_pUnitset->GetUnitsubsetList()->GetCount();
}

void  CItemAndUnitsubset::ReadXMLData( CBCXMLItem* pItem )
{
	m_strItemName = pItem->GetValue( ANSI8("ItemName") );
	m_bListContainsPositiveItems = pItem->GetValue( ANSI8("Pos") ) == ANSI8("1") ? true : false;

	long iCount = pItem->GetCount( ANSI8("Unitsubset") );
	for( long i=0; i<iCount; i++ )
	{
		CStringANSI8 strUnitsubsetUTF8 = pItem->GetValue( ANSI8("Unitsubset") );

		#ifdef UNICODE
		USES_CONVERSION;
		CString strUnitsubset = A2T( strUnitsubsetUTF8 );
		m_Unitsubsets.AddTail( strUnitsubset );
		#else
		m_Unitsubsets.AddTail( strUnitsubsetUTF8 );
		#endif
	}
}


void  CItemAndUnitsubset::AppendDataToXMLString( CStringANSI8& strData )
{
	strData += ANSI8("<Item>");
	strData += ANSI8("<ItemName>") + CStringANSI8( m_strItemName ) + ANSI8("</ItemName>\n");

	strData += ANSI8("<Pos>") + CBCStringANSI8::BoolAsString10( m_bListContainsPositiveItems ) + ANSI8("</Pos>\n");

	POSITION pos = m_Unitsubsets.GetHeadPosition();
	while( pos )
	{
		#ifdef UNICODE
		CString strUnitsubset = m_Unitsubsets.GetNext( pos );
		USES_CONVERSION;
		CStringANSI8  strUnitsubsetUTF8 = T2A( strUnitsubset );
		strData += ANSI8("<Unitsubset>") + strUnitsubsetUTF8 + ANSI8("</Unitsubset>\n");
		#else UNICODE
		strData += ANSI8("<Unitsubset>") + m_Unitsubsets.GetNext( pos ) + ANSI8("</Unitsubset>\n");
		#endif UNICODE
	}
	strData += ANSI8("</Item>\n");
}

bool  CItemAndUnitsubset::ExistsInList( CString strUnitsubset )
{
	POSITION pos = m_Unitsubsets.GetHeadPosition();
	while( pos )
	{
		CString strUnitsubsetInList = m_Unitsubsets.GetNext( pos );
		if( strUnitsubset == strUnitsubsetInList ){ return true; }
	}
	return false;
}
*/
CUnitset::CUnitset()
{
	m_bFlag_LoadAnimations = true;
	m_fCombatRandomness01 = 0.75f;

	m_fUnitAgeCombatExperience = 0.0f;
	for( long i=0; i<4; i++ )
	{
		m_fCombatLevelExperience[i] = 0.0f;
		m_fCombatLevelMultiplier[i] = 1.0f;
	}

	//m_AnimationManager.SetUnitset( this );
	//Clear();
}

void CUnitset::SetCombatRandomness01( float f )
{
	if( f < 0.0f ){ f = 0.0f; }
	if( f > 1.0f ){ f = 1.0f; }
	m_fCombatRandomness01 = f;
}


CUnitsetBriefDesc* CUnitset::GetUnitsetBriefDescFromIdentifier( CString strUnitsetIdentifier )
{
	std::list< CUnitsetBriefDesc* >::iterator iter;
	for( iter = CUnitset::s_AvailableUnitsets.begin(); iter != CUnitset::s_AvailableUnitsets.end(); ++iter )
	{
		CUnitsetBriefDesc* pBriefDesc = *iter;
		if( pBriefDesc->m_strLocalFile == strUnitsetIdentifier )
		{
			return pBriefDesc;
		}
	}
	for( iter = CUnitset::s_AvailableUnitsets.begin(); iter != CUnitset::s_AvailableUnitsets.end(); ++iter )
	{
		CUnitsetBriefDesc* pBriefDesc = *iter;
		if( pBriefDesc->m_strFileId == strUnitsetIdentifier )
		{
			return pBriefDesc;
		}
	}
	return NULL;
}

/*
#define ADD_SHIP_SOUNDS( templat ) \
	templat->OnSelectSoundFile( "Data\\Sound\\ShipB1.wav" );  \
	templat->OnSelectSoundFile( "Data\\Sound\\ShipB2.wav" ); \
	templat->OnSelectSoundFile( "Data\\Sound\\ShipB3.wav" );
*/


void CUnitset::ReadAvailableUnitsets()
{
	_tchdir( g_pApp->GetBaseDirectory() );
/*
	CApplicationVersion AppVer1;
	AppVer1.Set( "5.7.2" );
	AppVer1.Set( "5.07.2" );
	AppVer1.Set( "7.7.25" );

	CApplicationVersion AppVer2;
	AppVer2.Set( "7.7.2" );

	if( AppVer2 != AppVer1 )
	{
		int z=0;
	}
	if( AppVer2 <= AppVer1 )
	{
		int z=0;
	}
	if( AppVer2 >= AppVer1 )
	{
		int z=0;
	}
	if( AppVer1 <= AppVer2 )
	{
		int z=0;
	}
	if( AppVer1 >= AppVer2 )
	{
		int z=0;
	}
*/

	// Read the directories inside "Unitsets"
	CLocalSMUFiles LocalFiles;
	LocalFiles.m_bUnitsets = true;
	LocalFiles.ShowOnlyLatestVersions( true );
	LocalFiles.ReadLocalFiles();
	//LocalFiles.ShowOnlyLatestVersions();
	POSITION pos = LocalFiles.m_LocalFiles.GetHeadPosition();
	while( pos )
	{
		CHeaderInformationForFile* pHeaderFile = LocalFiles.m_LocalFiles.GetNext( pos );
		//CString strDirectoryPath = fileFind.GetFilePath();
		//CString strDirectoryName = fileFind.GetFileName();

		CUnitsetBriefDesc* pDesc = new CUnitsetBriefDesc();
		pDesc->m_strLocalFile = pHeaderFile->m_strLocalFilename;
		pDesc->m_strFileId = _T("");
		pDesc->m_strApplicationVersionRequired = _T("");

		CUnitset::s_AvailableUnitsets.push_back( pDesc );
	}

	// Read the directories inside "Unitsets"
	/*
	I think this code is old - a holdover from when rules were stores in directories, rather than files
	CFileFind fileFind;
	BOOL bResult = fileFind.FindFile( _T("Data\\Unitsets\\*.*") );
	while( bResult )
	{
		bResult = fileFind.FindNextFile();
		if( fileFind.IsDirectory() && fileFind.IsDots() == FALSE )
		{
			CString strDirectoryPath = fileFind.GetFilePath();
			CString strDirectoryName = fileFind.GetFileName();

			CUnitsetBriefDesc* pDesc = new CUnitsetBriefDesc();
			pDesc->m_strLocalFile = strDirectoryName;
			pDesc->m_strFileId = strDirectoryName;

			CUnitset::s_AvailableUnitsets.push_back( pDesc );

			// Grab the unitset description
			CStdioFile file;
			if( file.Open( strDirectoryPath + "\\Unitset.desc", CFile::modeRead | CFile::typeText ) )
			{
				// ignore everything larger than 100K
				if( file.GetLength() >= 100000 )
				{
					CString strText;
					strText.Format( "Cannot read unitset files over 100K (%s).", strDirectoryPath + "\\Unitset.desc" );
					AfxMessageBox( strText );
				}
				else
				{
					CString strLine;
					CString strKey;
					CString strData;
					while( file.ReadString( strLine ) )
					{
						if( strLine.IsEmpty() ) continue;
						//strLine.TrimLeft( " " );

						strKey = CBCString::GetEverythingBefore( strLine, "=" );
						strKey.TrimLeft( " " );
						strKey.TrimRight( " " );

						strData = CBCString::GetEverythingAfter( strLine, "=" );
						strData.TrimLeft( " " );
						strData.TrimRight( " " );

						/-*
						if( strKey == "Title" )
						{
							pDesc->m_strTitle = strData;
						}
						*-/
						if( strKey == "ApplicationVersionRequired" )
						{
							pDesc->m_strApplicationVersionRequired = strData;
						}
						//maybe I should create an ApplicationVersion class to do comparisons?
						//	I need that functionality in multiple places
					}
				}
			}
		}
	}
	*/
}
/*
CUnitsetBriefDesc* CUnitset::GetUnitsetBriefDescByDesc( CString strUnitsetTitle )
{
	std::list< CUnitsetBriefDesc* >::iterator iter;
	for( iter = CUnitset::s_AvailableUnitsets.begin(); iter != CUnitset::s_AvailableUnitsets.end(); ++iter )
	{
		CUnitsetBriefDesc* pBriefDesc = *iter;
		if( pBriefDesc->m_strTitle == strUnitsetTitle )
		{
			return pBriefDesc;
		}
	}
	return NULL;
}
*/
/*
CString  CUnitset::GetUnitsetTitle()
{
	if( m_strLocalFile != "" ){ return CBCString::GetEverythingBefore( m_strLocalFile, "." ); }
	if( m_strFileId != "" ){ return CBCString::GetEverythingBefore( m_strFileId, "." ); }
	return "";
}
*/
CString  CUnitset::RemoveDerivedFromAuthor( CString strAuthor )
{
	CString strOldDerivedFrom = m_strDerivedFromAuthor;
	CString strNewDerivedFrom;
	CString strSingleAuthor;
	while( strOldDerivedFrom != _T("") )
	{
		strSingleAuthor = CBCString::GetEverythingBefore( strOldDerivedFrom, _T(", ") );
		strOldDerivedFrom = CBCString::GetEverythingAfter( strOldDerivedFrom, _T(", ") );
		if( strAuthor != strSingleAuthor )
		{
			if( strNewDerivedFrom != _T("") ){ strNewDerivedFrom += _T(", "); }
			strNewDerivedFrom += strSingleAuthor;
		}
	}
	m_strDerivedFromAuthor = strNewDerivedFrom;
	return m_strDerivedFromAuthor;
}

CString  CUnitset::GetDescriptionInSafeHtmlFormat()
{
	CString str = m_strDescription;
	// Protect
	//str.Replace( "<b>", "[b]" );
	//str.Replace( "</b>", "[/b]" );
	//
	str.Replace( _T("<"), _T("&lt;") );
	str.Replace( _T(">"), _T("&gt;") );
	str.Replace( _T("\n"), _T("<br>") );
	// Unprotect
	str.Replace( _T("[b]"), _T("<b>") );
	str.Replace( _T("[/b]"), _T("</b>") );
	str.Replace( _T("[u]"), _T("<u>") );
	str.Replace( _T("[/u]"), _T("</u>") );
	//
	return str;
}

CString  CUnitset::GetTerrainSummaryInSafeHtmlFormat()
{
	CString str = m_strTerrainSummary;
	// Protect
	//str.Replace( "<b>", "[b]" );
	//str.Replace( "</b>", "[/b]" );
	//
	str.Replace( _T("<"), _T("&lt;") );
	str.Replace( _T(">"), _T("&gt;") );
	str.Replace( _T("\n"), _T("<br>") );
	// Unprotect
	str.Replace( _T("[b]"), _T("<b>") );
	str.Replace( _T("[/b]"), _T("</b>") );
	str.Replace( _T("[u]"), _T("<u>") );
	str.Replace( _T("[/u]"), _T("</u>") );
	//
	return str;
}

CString  CUnitset::GetBuildingSummaryInSafeHtmlFormat()
{
	CString str = m_strBuildingSummary;
	// Protect
	//str.Replace( "<b>", "[b]" );
	//str.Replace( "</b>", "[/b]" );
	//
	str.Replace( _T("<"), _T("&lt;") );
	str.Replace( _T(">"), _T("&gt;") );
	str.Replace( _T("\n"), _T("<br>") );
	// Unprotect
	str.Replace( _T("[b]"), _T("<b>") );
	str.Replace( _T("[/b]"), _T("</b>") );
	str.Replace( _T("[u]"), _T("<u>") );
	str.Replace( _T("[/u]"), _T("</u>") );
	//
	return str;
}

CString  CUnitset::GetUnitSummaryInSafeHtmlFormat()
{
	CString str = m_strUnitSummary;
	// Protect
	//str.Replace( "<b>", "[b]" );
	//str.Replace( "</b>", "[/b]" );
	//
	str.Replace( _T("<"), _T("&lt;") );
	str.Replace( _T(">"), _T("&gt;") );
	str.Replace( _T("\n"), _T("<br>") );
	// Unprotect
	str.Replace( _T("[b]"), _T("<b>") );
	str.Replace( _T("[/b]"), _T("</b>") );
	str.Replace( _T("[u]"), _T("<u>") );
	str.Replace( _T("[/u]"), _T("</u>") );
	//
	return str;
}

CString  CUnitset::GetTechSummaryInSafeHtmlFormat()
{
	CString str = m_strTechSummary;
	// Protect
	//str.Replace( "<b>", "[b]" );
	//str.Replace( "</b>", "[/b]" );
	//
	str.Replace( _T("<"), _T("&lt;") );
	str.Replace( _T(">"), _T("&gt;") );
	str.Replace( _T("\n"), _T("<br>") );
	// Unprotect
	str.Replace( _T("[b]"), _T("<b>") );
	str.Replace( _T("[/b]"), _T("</b>") );
	str.Replace( _T("[u]"), _T("<u>") );
	str.Replace( _T("[/u]"), _T("</u>") );
	//
	return str;
}
/*
void  CUnitset::Clear()
{
	m_iNextBuildOptionId = 1;

	m_bGoodChecksum = false;

	//m_iDownloadId = 0;
	m_strLocalFile = _T("");
	//m_strFileId = "";
	//m_strFilename = "";
	//m_strRelativeBasePath = "";
	//m_strTitle = "";
	//m_strAuthor = "(local)";
	m_strDescription = _T("");

	m_fCityDefaultViewRange = 0.0f;
	m_fCityOilConsumption = 0.0f;
	m_fCityFoodConsumption = 0.0f;

	m_fCityGroundUnitRepairRate = 0.0f;
	m_fCitySeaUnitRepairRate = 0.0f;
	m_fCityAirUnitRepairRate = 0.0f;

	m_fResourceDefaultViewRange = 0.0f;
	m_fAirfieldDefaultViewRange = 0.0f;
	//m_fAirfieldConstructionCost = 0.0f;

	while( m_MovementUnitTypes.IsEmpty() == FALSE ){ delete m_MovementUnitTypes.RemoveHead(); }
	while( m_CombatUnitTypes.IsEmpty() == FALSE ){ delete m_CombatUnitTypes.RemoveHead(); }

	FreeUnitTexturesAndAnimations();
	//m_AnimationManager.FreeAnimations();

	//pCurrentMovementUnitType = NULL;
	while( m_CityViewRangeList.IsEmpty() == FALSE ){ delete m_CityViewRangeList.RemoveHead(); }
	while( m_ResourceViewRangeList.IsEmpty() == FALSE ){ delete m_ResourceViewRangeList.RemoveHead(); }
	while( m_AirfieldViewRangeList.IsEmpty() == FALSE ){ delete m_AirfieldViewRangeList.RemoveHead(); }
	while( m_AirfieldConstructionCostList.IsEmpty() == FALSE ){ delete m_AirfieldConstructionCostList.RemoveHead(); }
	while( m_AirfieldProductionConsumptionList.IsEmpty() == FALSE ){ delete m_AirfieldProductionConsumptionList.RemoveHead(); }
	while( m_UnitDefaultViewRangeList.IsEmpty() == FALSE ){ delete m_UnitDefaultViewRangeList.RemoveHead(); }

	while( m_BuildOptionList.IsEmpty() == FALSE ){ delete m_BuildOptionList.RemoveHead(); }
	while( m_UnitTemplateList.IsEmpty() == FALSE ){ delete m_UnitTemplateList.RemoveHead(); }
	while( m_BuildingDescriptionList.IsEmpty() == FALSE ){ delete m_BuildingDescriptionList.RemoveHead(); }

	m_InitialMilitiaUnitList.RemoveAll();

	while( m_InitialCanBuildUnitList.IsEmpty() == FALSE ){ delete m_InitialCanBuildUnitList.RemoveHead(); }
	while( m_InitialCanBuildBuildingList.IsEmpty() == FALSE ){ delete m_InitialCanBuildBuildingList.RemoveHead(); }
	while( m_InitialFreeTechnologyList.IsEmpty() == FALSE ){ delete m_InitialFreeTechnologyList.RemoveHead(); }
	while( m_InitialFreeUnitCoastalCityList.IsEmpty() == FALSE ){ delete m_InitialFreeUnitCoastalCityList.RemoveHead(); }
	while( m_InitialFreeUnitLandlockedCityList.IsEmpty() == FALSE ){ delete m_InitialFreeUnitLandlockedCityList.RemoveHead(); }

	//while( m_Allow_TechnologyList.IsEmpty() == FALSE ){ delete m_Allow_TechnologyList.RemoveHead(); }
	//while( m_Allow_UnitList.IsEmpty() == FALSE ){ delete m_Allow_UnitList.RemoveHead(); }
	//while( m_Allow_BuildingList.IsEmpty() == FALSE ){ delete m_Allow_BuildingList.RemoveHead(); }

	m_fUnitAgeCombatExperience = 0.0f;
	for( long i=0; i<4; i++ )
	{
		m_fCombatLevelExperience[i] = 0.0f;
		m_fCombatLevelMultiplier[i] = 1.0f;
		m_strCombatLevelName[i] = _T("");
	}

	while( m_TechnologyList.IsEmpty() == FALSE ){ delete m_TechnologyList.RemoveHead(); }
	while( m_TechTreeNodes.IsEmpty() == FALSE )
	{
		CTechTreeNode* pTechTreeNode = m_TechTreeNodes.RemoveHead();
		delete pTechTreeNode;
		//delete m_TechTreeNodes.RemoveHead();
	}

	while( m_AnalysisList.IsEmpty() == FALSE ){ delete m_AnalysisList.RemoveHead(); }
}
*/
bool CUnitset::LoadUnitset( CString strFullFilename )
{
	//CString strFilePath = g_pApp->GetBaseDirectory() + "\\Data\\Unitsets\\" + pFileHeader->GetLocalFilename();

	// Read the first four bytes of the file to determine if this is an XML file or binary file
	CSerial  Serial;
	Serial.ReadFile2( strFullFilename, 4 );
	long iFirstFourBytes = Serial.ExtractLong();
	if( iFirstFourBytes == 1768838460 ) // XML file = "<Uni" as in <Unitset>
	{
		if( this->ReadUnitsetXMLFile( strFullFilename ) )
		{
			if( this->GetGoodChecksum() == false )//&& Public::m_bErrorBoxOnBadChecksum )
			{
				//CString strText;
				//strText.Format( Lang( 132, _T("Bad Ruleset Checksum [ %s ]") ), pFileHeader->GetLocalFilename() );
				//CWarningDialog  Dialog( CWarningDialog::IconCheck, Lang( 53, _T("Error") ), strText, false );
				//Dialog.DoModal();
				return true;
			}
			//m_UnitsetList.AddTail( pUnitset );
			return true;
		}
	}
	eif( iFirstFourBytes == UNITSET_VALIDATION_KEY ) // binary file = 1821987124
	{
		if( this->ReadUnitsetBinaryFile( strFullFilename ) )
		{
			if( this->GetGoodChecksum() == false )//&& Public::m_bErrorBoxOnBadChecksum )
			{
				//CString strText;
				//strText.Format( Lang( 132, _T("Bad Ruleset Checksum [ %s ]") ), pFileHeader->GetLocalFilename() );
				//CWarningDialog  Dialog( CWarningDialog::IconCheck, Lang( 53, _T("Error") ), strText, false );
				//Dialog.DoModal();
				return true;
			}
			//m_UnitsetList.AddTail( pUnitset );
			//return pUnitset;
			return true;
		}
	}
	return false;
}

void CUnitset::WriteUnitsetBinaryFile( CString strFullFilename, bool bChangeFileUID )
{
	if( bChangeFileUID )
	{
		// m_strFileUID = Title.u.LongTimestamp
		m_strFileUID = CBCString::GenerateFileUID( m_strTitle + _T(".u.") );
	}

	CSerial Serial;
	Serialize( &Serial );
	Serial.WriteFile2( strFullFilename );
}

void CUnitset::Serialize( CSerial *pSerial )
{
	long iSanityCheck = UNITSET_VALIDATION_KEY;
	pSerial->Serialize( iSanityCheck );

	long iVersion = 1;
	pSerial->Serialize( iVersion );

	CStringANSI8 strVersionUTF8;
	strVersionUTF8 = g_pApp->GetApplicationVersion().GetString();
	pSerial->SerializeANSI8( strVersionUTF8 );

	// Write Blank Checksum
	long iChecksumStart = pSerial->GetCurrentLocation();
	SerializeChecksum( pSerial, 0,0, 0,0 );

	// Write Header
	long iStartHeader = pSerial->GetCurrentLocation();
	SerializeHeader( pSerial );
	long iEndHeader = pSerial->GetCurrentLocation()-1;

	// Write Data
	long iStartBody = pSerial->GetCurrentLocation();
	SerializeBody( pSerial );
	long iEndBody = pSerial->GetCurrentLocation()-1;

	// Update the Checksum in the header
	long iCurrentLocation = pSerial->GetCurrentLocation();
	pSerial->SetCurrentLocation( iChecksumStart );
	SerializeChecksum( pSerial, iStartHeader,iEndHeader, iStartBody,iEndBody );
	pSerial->SetCurrentLocation( iCurrentLocation );
}


void CUnitset::SerializeChecksum( CSerial* pSerial, long iStartHeader, long iEndHeader, long iStartBody, long iEndBody )
{
	char cVersion = 1;
	pSerial->Serialize( cVersion );

	// Some randomization (to hinder cracking)
	CStringANSI8 strTempUTF8;
	CStringANSI8 strRandomizerStringANSI8;
	LARGE_INTEGER LargeInt = CBCStopwatch2::GetTime_LargeInteger();

	// Add a randomizer string
	srand( timeGetTime() );
	strRandomizerStringANSI8 += CBCString::GetRandString_NumbersLowercase( 20 );
	strTempUTF8.Format( ANSI8("%02u"), LargeInt.LowPart%100 ); 
	strRandomizerStringANSI8 += strTempUTF8;
	strRandomizerStringANSI8 += CBCString::GetRandString_NumbersLowercase( 10 );
	strTempUTF8.Format( ANSI8("%02u"), ((LargeInt.LowPart/100)+65)%100 );
	strRandomizerStringANSI8 += strTempUTF8;
	strRandomizerStringANSI8 += CBCString::GetRandString_NumbersLowercase( 10 );
	strTempUTF8.Format( ANSI8("%02u"), ((LargeInt.LowPart/100)+16)%100 );
	strRandomizerStringANSI8 += strTempUTF8;
	strRandomizerStringANSI8 += CBCString::GetRandString_NumbersLowercase( 10 );
	strTempUTF8.Format( ANSI8("%02u"), ((LargeInt.LowPart/10000)+11)%100 );
	strRandomizerStringANSI8 += strTempUTF8;
	strRandomizerStringANSI8 += CBCString::GetRandString_NumbersLowercase( 10 );
	strTempUTF8.Format( ANSI8("%02u"), ((LargeInt.LowPart/1000000)+74)%100 );
	strRandomizerStringANSI8 += strTempUTF8;
	srand( timeGetTime()+rand() );
	strRandomizerStringANSI8 += CBCString::GetRandString_NumbersLowercase( 10 );
	pSerial->SerializeANSI8( strRandomizerStringANSI8 );

	// Add a header checksum (based on randomizer + header)
	//CStringANSI8 strHeaderChecksumUTF8 = CBCString::GetChecksum( strRandomizerStringANSI8, strHeaderUTF8 );
	CStringANSI8 strHeaderChecksumUTF8 = CBCString::GetChecksum( strRandomizerStringANSI8, pSerial->GetRawData(), iStartHeader, iEndHeader );
	pSerial->SerializeANSI8( strHeaderChecksumUTF8 );

	// Add a body checksum (based on randomizer + body)
	//CStringANSI8 strBodyChecksumUTF8 = CBCString::GetChecksum( strRandomizerStringANSI8, strBodyUTF8 );
	CStringANSI8 strBodyChecksumUTF8 = CBCString::GetChecksum( strRandomizerStringANSI8, pSerial->GetRawData(), iStartBody, iEndBody );
	pSerial->SerializeANSI8( strBodyChecksumUTF8 );

	// Add a header+body checksum (based on HeaderChecksum + BodyChecksum)
	//CStringANSI8 strFullChecksumUTF8 = CBCString::GetChecksum( strHeaderChecksumUTF8, strBodyChecksumUTF8 );
	CStringANSI8 strFullChecksumUTF8 = CBCString::GetChecksum( strHeaderChecksumUTF8, strBodyChecksumUTF8 );
	pSerial->SerializeANSI8( strFullChecksumUTF8 );

	long iBodyStart = 0;
	pSerial->Serialize( iStartBody );
/*
	CString strNewXML;
	strNewXML = ANSI8("<C>\n");

		strNewXML += ANSI8("<1>") + strRandomizerStringANSI8 + ANSI8("</1>\n");

		CStringANSI8 strHeaderChecksumUTF8 = CBCString::GetChecksum( strRandomizerStringANSI8, strHeaderUTF8 );
		strNewXML += ANSI8("<2>") + strHeaderChecksumUTF8 + ANSI8("</2>\n");

		CStringANSI8 strBodyChecksumUTF8 = CBCString::GetChecksum( strRandomizerStringANSI8, strBodyUTF8 );
		strNewXML += ANSI8("<3>") + strBodyChecksumUTF8 + ANSI8("</3>\n");

		CStringANSI8 strFullChecksumUTF8 = CBCString::GetChecksum( strHeaderChecksumUTF8, strBodyChecksumUTF8 );
		strNewXML += ANSI8("<4>") + strFullChecksumUTF8 + ANSI8("</4>\n");

	strNewXML += ANSI8("</C>\n");
	strXML += strNewXML;
*/
}

void CUnitset::SerializeHeader( CSerial* pSerial )
{
	short sVersion = 3; // 2 is unicode
	pSerial->Serialize( sVersion );

	if( sVersion == 1 )
	{
		pSerial->SerializeANSI8( m_strFileUID );
		pSerial->SerializeANSI8( m_strTitle );
		pSerial->SerializeANSI8( m_strAuthor );
		pSerial->SerializeANSI8( m_strDerivedFromAuthor );
		pSerial->SerializeANSI8( m_strVersionAsTimestamp );
	}
	if( sVersion >= 2 )
	{
		pSerial->SerializeUnicode( m_strFileUID );
		pSerial->SerializeUnicode( m_strTitle );
		pSerial->SerializeUnicode( m_strAuthor );
		pSerial->SerializeUnicode( m_strDerivedFromAuthor );
		pSerial->SerializeUnicode( m_strVersionAsTimestamp );
	}

	long iCount = 0;
	iCount = m_UnitTemplateList.GetCount();
	pSerial->Serialize( iCount );
	iCount = m_TechnologyList.GetCount();
	pSerial->Serialize( iCount );
	iCount = m_BuildingDescriptionList.GetCount();
	pSerial->Serialize( iCount );

	if( sVersion == 1 )
	{
		pSerial->SerializeANSI8( m_strDescription );
		pSerial->SerializeANSI8( m_strUnitSummary );
		pSerial->SerializeANSI8( m_strTechSummary );
		pSerial->SerializeANSI8( m_strBuildingSummary );
		pSerial->SerializeANSI8( m_strTerrainSummary );
	}
	if( sVersion >= 2 )
	{
		pSerial->SerializeUnicode( m_strDescription );
		pSerial->SerializeUnicode( m_strUnitSummary );
		pSerial->SerializeUnicode( m_strTechSummary );
		pSerial->SerializeUnicode( m_strBuildingSummary );
		pSerial->SerializeUnicode( m_strTerrainSummary );
	}

	iCount = m_UnitsubsetList.GetCount();
	pSerial->Serialize( iCount );
	POSITION pos = m_UnitsubsetList.GetHeadPosition();
	while( pos )
	{
		CString strUnitsubset = m_UnitsubsetList.GetNext( pos );
		if( sVersion == 1 )
		{
			pSerial->SerializeANSI8( strUnitsubset );
		}
		if( sVersion >= 2 )
		{
			pSerial->SerializeUnicode( strUnitsubset );
		}
	}

	// Version 3
	//   Construct a list of all the UnitTemplateImages
	if( sVersion >= 3 )
	{
		m_UnitTemplateImages.RemoveAll();
		POSITION pos = m_UnitTemplateList.GetHeadPosition();
		while( pos )
		{
			CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
			ASSERT( ((CUnitTemplateB*)pUnitTemplate)->GetUnitTemplateImage() );
			if( ((CUnitTemplateB*)pUnitTemplate)->GetUnitTemplateImage() )
			{
				CString strUnitTemplateImage = ((CUnitTemplateB*)pUnitTemplate)->GetUnitImageName();
				//GetUnitTemplateImage()->GetInternalName();
				ASSERT( strUnitTemplateImage != _T("") );
				if( strUnitTemplateImage != _T("") )
				{
					m_UnitTemplateImages.AddTail( strUnitTemplateImage );
				}
			}
		}
		long iUnitTemplateImages = m_UnitTemplateImages.GetCount();
		pSerial->Serialize( iUnitTemplateImages );
		pos = m_UnitTemplateImages.GetHeadPosition();
		while( pos )
		{
			CString strUnitTemplateImage = m_UnitTemplateImages.GetNext( pos );
			pSerial->SerializeUnicode( strUnitTemplateImage );
		}
	}
	int h=0;

/*
	//
	CString strData;
	strData += ANSI8("<FileUID>") + CStringANSI8( m_strFileUID ) + ANSI8("</FileUID>\n");
	strData += ANSI8("<Title>") + CStringANSI8( m_strTitle ) + ANSI8("</Title>\n");
	strData += ANSI8("<Author>") + CStringANSI8( m_strAuthor ) + ANSI8("</Author>\n");
	strData += ANSI8("<DerivedFromAuthor>") + CStringANSI8( m_strDerivedFromAuthor ) + ANSI8("</DerivedFromAuthor>\n");
	//strData += "<UnitsetUniqueId>" + m_strUnitsetUniqueId + "</UnitsetUniqueId>\n";
	strData += ANSI8("<Version>") + CStringANSI8( m_strVersionAsTimestamp ) + ANSI8("</Version>\n");
	//strData += "<Version>" + g_pApp->GetCurrentTimeSortString() + "</Version>\n";

	strData += ANSI8("<AppVersion>") + CStringANSI8( g_pApp->GetApplicationVersion().GetString() ) + ANSI8("</AppVersion>\n");

	strData += ANSI8("<UnitCount>") + CBCStringANSI8::LongAsString( m_UnitTemplateList.GetCount() ) + ANSI8("</UnitCount>\n");
	strData += ANSI8("<TechCount>") + CBCStringANSI8::LongAsString( m_TechnologyList.GetCount() ) + ANSI8("</TechCount>\n");
	strData += ANSI8("<BuildingCount>") + CBCStringANSI8::LongAsString( m_BuildingDescriptionList.GetCount() ) + ANSI8("</BuildingCount>\n");

	strData += ANSI8("<Description>") + CStringANSI8( m_strDescription ) + ANSI8("</Description>\n");

	//strData += "<Summary>" + m_strWebpageSummary + "</Summary>";
	strData += ANSI8("<UnitSummary>") + CStringANSI8( m_strUnitSummary ) + ANSI8("</UnitSummary>\n");
	strData += ANSI8("<TechSummary>") + CStringANSI8( m_strTechSummary ) + ANSI8("</TechSummary>\n");
	strData += ANSI8("<BuildingSummary>") + CStringANSI8( m_strBuildingSummary ) + ANSI8("</BuildingSummary>\n");
	strData += ANSI8("<TerrainSummary>") + CStringANSI8( m_strTerrainSummary ) + ANSI8("</TerrainSummary>\n");

	strData += ANSI8("<Unitsubsets>\n");
	POSITION pos = m_UnitsubsetList.GetHeadPosition();
	while( pos )
	{
		CString strUnitsubset = m_UnitsubsetList.GetNext( pos );
		strData += ANSI8("<Unitsubset>") + CStringANSI8( strUnitsubset ) + ANSI8("</Unitsubset>\n");
	}
	strData += ANSI8("</Unitsubsets>\n");
*/
}

void CUnitset::SerializeBody( CSerial* pSerial )
{
	long iCount = 0;
	POSITION pos;

	// 8 = Airfield Maintenance Costs
	// 9 = Airfield Cost (instead of Money)
	// 10 = flipped airfield maintenance cost to be "production,consumption"
	long iVersion = 10; // 7 = Combat Experience // 5 = Default Repair Rate //3; // Version 2 is unicode
	//long iVersion = 5;// 5 = Default Repair Rate //3; // Version 2 is unicode
	pSerial->Serialize( iVersion );

	pSerial->Serialize( m_fCombatRandomness01 ); // Version 3

	//
	// Unitsubsets and the bonuses associated with each (move code from below)
	//
	long iPasses = m_UnitsubsetList.GetCount() + 1;
	pSerial->Serialize( iPasses );
	for( long iPass=0; iPass<iPasses; iPass++ )
	{
		//CStringANSI8 strUnitsubset = "";
		CString strUnitsubset = _T("");
		if( iPass == 0 ){}
		else
		{
			strUnitsubset = m_UnitsubsetList.GetAt( m_UnitsubsetList.FindIndex( iPass-1 ) );
			if( iVersion == 1 )
			{
				pSerial->SerializeANSI8( strUnitsubset );
			}
			if( iVersion >= 2 )
			{
				pSerial->SerializeUnicode( strUnitsubset );
			}
		}
		/*
		CString strUnitsubset = _T("");
		if( iPass == 0 )
		{
			strData += ANSI8("<AllSubsets>");
		}
		else
		{
			strUnitsubset = m_UnitsubsetList.GetAt( m_UnitsubsetList.FindIndex( iPass-1 ) );
			strData += ANSI8("<Subset>\n");
			strData += ANSI8("<Name>") + CStringANSI8( strUnitsubset ) + ANSI8("</Name>\n");
		}
		*/
		pos = m_InitialFreeTechnologyList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeTechnologyList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				if( iVersion == 1 )
				{
					pSerial->SerializeANSI8( pUnitsubsetValue->m_strValue );
				}
				if( iVersion >= 2 )
				{
					pSerial->SerializeUnicode( pUnitsubsetValue->m_strValue );
				}
			}
		}
		if( iVersion == 1 )
		{
			pSerial->SerializeANSI8( "" );
		}
		if( iVersion >= 2 )
		{
			CString strEmpty = _T("");
			pSerial->SerializeUnicode( strEmpty );
		}
		/*
		strData += ANSI8("<Free>\n");
		pos = m_InitialFreeTechnologyList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeTechnologyList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Tech>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Tech>\n");
			}
		}
		*/
		pos = m_InitialFreeUnitCoastalCityList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitCoastalCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				if( iVersion == 1 )
				{
					pSerial->SerializeANSI8( pUnitsubsetValue->m_strValue );
				}
				if( iVersion >= 2 )
				{
					pSerial->SerializeUnicode( pUnitsubsetValue->m_strValue );
				}
			}
		}
		if( iVersion == 1 )
		{
			pSerial->SerializeANSI8( "" );
		}
		if( iVersion >= 2 )
		{
			CString strEmpty = _T("");
			pSerial->SerializeUnicode( strEmpty );
		}
		/*
		pos = m_InitialFreeUnitCoastalCityList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitCoastalCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Unit-Coastal>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Unit-Coastal>\n");
			}
		}
		*/
		pos = m_InitialFreeUnitLandlockedCityList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitLandlockedCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				if( iVersion == 1 )
				{
					pSerial->SerializeANSI8( pUnitsubsetValue->m_strValue );
				}
				if( iVersion >= 2 )
				{
					pSerial->SerializeUnicode( pUnitsubsetValue->m_strValue );
				}
			}
		}
		if( iVersion == 1 )
		{
			pSerial->SerializeANSI8( "" );
		}
		if( iVersion >= 2 )
		{
			CString strEmpty = _T("");
			pSerial->SerializeUnicode( strEmpty );
		}
		/*
		pos = m_InitialFreeUnitLandlockedCityList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitLandlockedCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Unit-Landlocked>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Unit-Landlocked>\n");
			}
		}
		strData += ANSI8("</Free>\n");
		*/

		pos = m_InitialCanBuildUnitList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				if( iVersion == 1 )
				{
					pSerial->SerializeANSI8( pUnitsubsetValue->m_strValue );
				}
				if( iVersion >= 2 )
				{
					pSerial->SerializeUnicode( pUnitsubsetValue->m_strValue );
				}
			}
		}
		if( iVersion == 1 )
		{
			pSerial->SerializeANSI8( "" );
		}
		if( iVersion >= 2 )
		{
			CString strEmpty = _T("");
			pSerial->SerializeUnicode( strEmpty );
		}
		/*
		strData += ANSI8("<InitialCanBuild>");
		pos = m_InitialCanBuildUnitList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Unit>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Unit>\n");
			}
		}
		*/

		pos = m_InitialCanBuildBuildingList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				if( iVersion == 1 )
				{
					pSerial->SerializeANSI8( pUnitsubsetValue->m_strValue );
				}
				if( iVersion >= 2 )
				{
					pSerial->SerializeUnicode( pUnitsubsetValue->m_strValue );
				}
			}
		}
		if( iVersion == 1 )
		{
			pSerial->SerializeANSI8( "" );
		}
		if( iVersion >= 2 )
		{
			CString strEmpty = _T("");
			pSerial->SerializeUnicode( strEmpty );
		}

		if( iVersion >= 6 )
		{
			pos = m_InitialCanBuildAirfieldImprovementList.GetHeadPosition();
			while( pos )
			{
				CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildAirfieldImprovementList.GetNext( pos );
				if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
				{
					pSerial->SerializeUnicode( pUnitsubsetValue->m_strValue );
				}
			}
			CString strEmpty = _T("");
			pSerial->SerializeUnicode( strEmpty );
		}
		/*
		pos = m_InitialCanBuildBuildingList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Building>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Building>\n");
			}
		}
		strData += ANSI8("</InitialCanBuild>");
		*/
		/*
		pos = m_AllowResearchList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_AllowResearchList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += "<ResearchAllowed>" + pUnitsubsetValue->m_strValue + "</ResearchAllowed>\n";
			}
		}
		*/

		//if( iPass == 0 ){ strData += ANSI8("</AllSubsets>\n"); }
		//else{ strData += ANSI8("</Subset>\n"); }
	}
	// Version 4
	if( iVersion >= 4 )
	{
		long iItemCount = 0;
		pos = m_InitialResources.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetStringLongValue* p = m_InitialResources.GetNext( pos );
			if( UnitsubsetExists( p->m_strUnitsubset ) )
			{
				iItemCount++;
			}
		}
		pSerial->Serialize( iItemCount );
		pos = m_InitialResources.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetStringLongValue* p = m_InitialResources.GetNext( pos );
			if( UnitsubsetExists( p->m_strUnitsubset ) )
			{
				pSerial->SerializeUnicode( p->m_strUnitsubset );
				pSerial->SerializeUnicode( p->m_strValue );
				pSerial->Serialize( p->m_iValue );
			}
		}
	}

	//strData += ANSI8("</UnitSubsets>\n");

	// Write "AllowTechnology" information
	/*
	strData += "<AllowTechnology>\n";
	pos = m_Allow_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CItemAndUnitsubset* pItemAndUnitsubset = m_Allow_TechnologyList.GetNext( pos );
		//pItemAndUnitsubset->AppendDataToXMLString( strData );
	}
	strData += "</AllowTechnology>\n";
	*/
	// Write "AllowUnit" information
	/*A
	strData += "<AllowUnit>\n";
	pos = m_Allow_UnitList.GetHeadPosition();
	while( pos )
	{
		CItemAndUnitsubset* pItemAndUnitsubset = m_Allow_UnitList.GetNext( pos );
		//pItemAndUnitsubset->AppendDataToXMLString( strData );
	}
	strData += "</AllowUnit>\n";
	*/

	// Write "AllowBuilding" information
	/*
	strData += "<AllowBuilding>\n";
	pos = m_Allow_BuildingList.GetHeadPosition();
	while( pos )
	{
		CItemAndUnitsubset* pItemAndUnitsubset = m_Allow_BuildingList.GetNext( pos );
		//pItemAndUnitsubset->AppendDataToXMLString( strData );
	}
	strData += "</AllowBuilding>\n";
	*/

	//
	// Animations used by this unitset
	//
		// Should I derive this information from the UnitTemplate information?
		

	//
	// Basic Combat/Movement Information
	//
		// Combat Unit Types
		iCount = m_CombatUnitTypes.GetCount();
		pSerial->Serialize( iCount );
		pos = m_CombatUnitTypes.GetHeadPosition();
		while( pos )
		{
			CCombatUnitType* pCombatUnitType = m_CombatUnitTypes.GetNext( pos );
			pCombatUnitType->Serialize( pSerial );
		}
	/*
		// Combat Unit Types
		strData += ANSI8("<CombatUnitTypes>\n");
		pos = m_CombatUnitTypes.GetHeadPosition();
		while( pos )
		{
			//m_CombatUnitTypes.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</CombatUnitTypes>\n");
	*/
		// Movement Unit Types
		iCount = m_MovementUnitTypes.GetCount();
		pSerial->Serialize( iCount );
		pos = m_MovementUnitTypes.GetHeadPosition();
		while( pos )
		{
			CMovementUnitType* pMovementUnitType = m_MovementUnitTypes.GetNext( pos );
			pMovementUnitType->Serialize( pSerial );
		}
	/*
		// Movement Unit Types
		strData += ANSI8("<MovementUnitTypes>\n");
		pos = m_MovementUnitTypes.GetHeadPosition();
		while( pos )
		{
			//m_MovementUnitTypes.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</MovementUnitTypes>\n");
	*/

	//
	// Categories
	//
		iCount = m_UnitCategories.GetCount();
		pSerial->Serialize( iCount );
		pos = m_UnitCategories.GetHeadPosition();
		while( pos )
		{
			//m_UnitCategories.GetNext( pos )->AppendDataToXMLString( strData );
			CUnitCategory* pUnitCategory = m_UnitCategories.GetNext( pos );
			pUnitCategory->Serialize( pSerial );
		}
		/*
		strData += ANSI8("<UnitCategories>\n");
		pos = m_UnitCategories.GetHeadPosition();
		while( pos )
		{
			//m_UnitCategories.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</UnitCategories>\n");
		*/

	//
	// City/Resource/Airfield View Ranges
	//
		// City Description
		pSerial->Serialize( m_fCityDefaultViewRange );
		iCount = GetCityViewRangeList()->GetCount();
		pSerial->Serialize( iCount );
		pos = GetCityViewRangeList()->GetHeadPosition();
		while( pos )
		{
			CViewRange* pViewRange = GetCityViewRangeList()->GetNext( pos );
			if( iVersion == 1 )
			{
				pSerial->SerializeANSI8( pViewRange->m_strUnitTag );
			}
			if( iVersion >= 2 )
			{
				pSerial->SerializeUnicode( pViewRange->m_strUnitTag );
			}
			pSerial->Serialize( pViewRange->m_fViewRange );
		}
		pSerial->Serialize( m_fCityOilConsumption );
		pSerial->Serialize( m_fCityFoodConsumption );

		if( iVersion >= 5 )
		{
			pSerial->Serialize( m_fCityGroundUnitRepairRate );
			pSerial->Serialize( m_fCitySeaUnitRepairRate );
			pSerial->Serialize( m_fCityAirUnitRepairRate );
		}

		// Resource Description
		pSerial->Serialize( m_fResourceDefaultViewRange );
		iCount = GetResourceViewRangeList()->GetCount();
		pSerial->Serialize( iCount );
		pos = GetResourceViewRangeList()->GetHeadPosition();
		while( pos )
		{
			CViewRange* pViewRange = GetResourceViewRangeList()->GetNext( pos );
			if( iVersion == 1 )
			{
				pSerial->SerializeANSI8( pViewRange->m_strUnitTag );
			}
			if( iVersion >= 2 )
			{
				pSerial->SerializeUnicode( pViewRange->m_strUnitTag );
			}
			pSerial->Serialize( pViewRange->m_fViewRange );
		}

		// Airfield Description
		//pSerial->Serialize( m_fAirfieldConstructionCost ); // Removed in Version 9
		// Airfield Maintenance Costs - Version 9
		iCount = m_AirfieldConstructionCostList.GetCount();
		pSerial->Serialize( iCount );
		pos = m_AirfieldConstructionCostList.GetHeadPosition();
		while( pos )
		{
			CStringAndFloat* pCost = m_AirfieldConstructionCostList.GetNext( pos );
			pSerial->SerializeUnicode( pCost->m_strValue );
			pSerial->Serialize( pCost->m_fValue );
		}

		pSerial->Serialize( m_fAirfieldDefaultViewRange );
		iCount = GetAirfieldViewRangeList()->GetCount();
		pSerial->Serialize( iCount );
		pos = m_AirfieldViewRangeList.GetHeadPosition();
		while( pos )
		{
			CViewRange* pViewRange = m_AirfieldViewRangeList.GetNext( pos );
			if( iVersion == 1 )
			{
				pSerial->SerializeANSI8( pViewRange->m_strUnitTag );
			}
			if( iVersion >= 2 )
			{
				pSerial->SerializeUnicode( pViewRange->m_strUnitTag );
			}
			pSerial->Serialize( pViewRange->m_fViewRange );
		}

		// Airfield Maintenance Costs - Version 8
		iCount = m_AirfieldProductionConsumptionList.GetCount();
		pSerial->Serialize( iCount );
		pos = m_AirfieldProductionConsumptionList.GetHeadPosition();
		while( pos )
		{
			CStringAndFloat* pProductionConsumption = m_AirfieldProductionConsumptionList.GetNext( pos );
			pSerial->SerializeUnicode( pProductionConsumption->m_strValue );
			pSerial->Serialize( pProductionConsumption->m_fValue );
		}

		// UnitDefault View Range
		iCount = m_UnitDefaultViewRangeList.GetCount();
		pSerial->Serialize( iCount );
		pos = m_UnitDefaultViewRangeList.GetHeadPosition();
		while( pos )
		{
			CViewRange* pViewRange = m_UnitDefaultViewRangeList.GetNext( pos );
			if( iVersion == 1 )
			{
				pSerial->SerializeANSI8( pViewRange->m_strUnitTag );
			}
			if( iVersion >= 2 )
			{
				pSerial->SerializeUnicode( pViewRange->m_strUnitTag );
			}
			pSerial->Serialize( pViewRange->m_fViewRange );
		}

	//
	// Unit Templates
	//
		iCount = m_UnitTemplateList.GetCount();
		pSerial->Serialize( iCount );
		pos = m_UnitTemplateList.GetHeadPosition();
		while( pos )
		{
			CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
			pUnitTemplate->Serialize( pSerial );
		}
		/*
		strData += ANSI8("<Units>\n");
		pos = m_UnitTemplateList.GetHeadPosition();
		while( pos )
		{
			//m_UnitTemplateList.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</Units>\n");
		*/

	//
	// Buildings
	//
		iCount = m_BuildingDescriptionList.GetCount();
		pSerial->Serialize( iCount );
		pos = m_BuildingDescriptionList.GetHeadPosition();
		while( pos )
		{
			CBuildingDescription* pBuildingDesc = m_BuildingDescriptionList.GetNext( pos );
			pBuildingDesc->Serialize( pSerial );
			//m_BuildingDescriptionList.GetNext( pos )->AppendDataToXMLString( strData );
		}
		/*
		strData += ANSI8("<Buildings>\n");
		pos = m_BuildingDescriptionList.GetHeadPosition();
		while( pos )
		{
			//m_BuildingDescriptionList.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</Buildings>\n");
		*/

	//
	// Airfield Improvements
	//
		if( iVersion >= 6 )
		{
			iCount = m_AirfieldImprovementList.GetCount();
			pSerial->Serialize( iCount );
			pos = m_AirfieldImprovementList.GetHeadPosition();
			while( pos )
			{
				CAirfieldImprovement* pImprove = m_AirfieldImprovementList.GetNext( pos );
				pImprove->Serialize( pSerial );
			}
		}

	//
	// Militia units
	//
		iCount = m_InitialMilitiaUnitList.GetCount();
		pSerial->Serialize( iCount );
		pos = m_InitialMilitiaUnitList.GetHeadPosition();
		while( pos )
		{
			CString strMilitia = m_InitialMilitiaUnitList.GetNext( pos );
			if( iVersion == 1 )
			{
				pSerial->SerializeANSI8( strMilitia );
			}
			if( iVersion >= 2 )
			{
				pSerial->SerializeUnicode( strMilitia );
			}
		}
		/*
		strData += ANSI8("<Militia>\n");
		pos = m_InitialMilitiaUnitList.GetHeadPosition();
		while( pos )
		{
			CString strMilitia = m_InitialMilitiaUnitList.GetNext( pos );
			strData += ANSI8("<Unit>") + CStringANSI8( strMilitia ) + ANSI8("</Unit>\n");
		}
		strData += ANSI8("</Militia>\n");
		*/

	//
	// Combat Experience
	//
	if( iVersion >= 7 )
	{
		pSerial->Serialize( m_fUnitAgeCombatExperience );
		for( long i=0; i<4; i++ )
		{
			pSerial->Serialize( m_fCombatLevelExperience[i] );
			pSerial->Serialize( m_fCombatLevelMultiplier[i] );
			pSerial->SerializeUnicode( m_strCombatLevelName[i] );
		}
	}

	//
	// Technology
	//
		iCount = m_TechnologyList.GetCount();
		pSerial->Serialize( iCount );
		pos = m_TechnologyList.GetHeadPosition();
		while( pos )
		{
			CTechnologyDesc* pTechDesc = m_TechnologyList.GetNext( pos );
			pTechDesc->Serialize( pSerial );
			//m_TechnologyList.GetNext( pos )->AppendDataToXMLString( strData );
		}
		/*
		strData += ANSI8("<Technology>\n");
		pos = m_TechnologyList.GetHeadPosition();
		while( pos )
		{
			//m_TechnologyList.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</Technology>\n");
		*/

		// Tech Tree nodes - this is stored separately because the same tech can appear
		//   in multiple places in the tech tree - e.g. a basic technology.  This makes it
		//   impossible to put all the child/parent tree information into a CTechnology object.
		// Instead, I have multiple copies of the "Electronics 1" tech.
//		strData += ANSI8("<TechTree>\n");
		/*
		pos = m_TechTreeHeadNodes.GetHeadPosition();
		while( pos )
		{
			//m_TechTreeHeadNodes.GetNext( pos )->AppendDataToXMLString( strData );
		}
		*/
		iCount = 0;
		pos = m_TechTreeNodes.GetHeadPosition();
		while( pos )
		{
			CTechTreeNode* pTechTreeNode = m_TechTreeNodes.GetNext( pos );
			if( pTechTreeNode->m_pParentNode == NULL )
			{
				iCount++;
			}
		}
		pSerial->Serialize( iCount );
		pos = m_TechTreeNodes.GetHeadPosition();
		while( pos )
		{
			CTechTreeNode* pTechTreeNode = m_TechTreeNodes.GetNext( pos );
			if( pTechTreeNode->m_pParentNode == NULL )
			{
				pTechTreeNode->Serialize( pSerial );
			}
		}
		/*
		pos = m_TechTreeNodes.GetHeadPosition();
		while( pos )
		{
			CTechTreeNode* pTechTreeNode = m_TechTreeNodes.GetNext( pos );
			//if( pTechTreeNode->m_ParentNodes.IsEmpty() )
			if( pTechTreeNode->m_pParentNode == NULL )
			{
				//pTechTreeNode->AppendDataToXMLString( strData );
			}
		}
		strData += ANSI8("</TechTree>\n");
		*/
	//
	// Analysis
	//
		iCount = m_AnalysisList.GetCount();
		pSerial->Serialize( iCount );
		pos = m_AnalysisList.GetHeadPosition();
		while( pos )
		{
			CAnalysisUnitTemplateList* pAnalysis = m_AnalysisList.GetNext( pos );
			pAnalysis->Serialize( pSerial );
		}
	/*
		strData += ANSI8("<AnalysisSet>\n");
		pos = m_AnalysisList.GetHeadPosition();
		while( pos )
		{
			CAnalysisUnitTemplateList* pAnalysis = m_AnalysisList.GetNext( pos );
			//pAnalysis->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</AnalysisSet>\n");

	strData += ANSI8("</Body>");
	*/
}

bool CUnitset::ReadUnitsetBinaryFile( CString strFilePath )
{
	//CStringANSI8 strUnitsetData;
	//if( LoadUnitsetFileDataAndValidateChecksum( strFullFilename, strUnitsetData ) == false ) return false;
	CSerial Serial;
	Serial.ReadFile2( strFilePath );
	if( Deserialize( &Serial ) )
	{
		return true;
	}
	return false;
}

bool CUnitset::Deserialize( CSerial *pSerial )
{
	long iSanityCheck = 0;
	pSerial->Deserialize( iSanityCheck );
	if( iSanityCheck != UNITSET_VALIDATION_KEY ){ ASSERT( false ); return false; }

	long iVersion = 0;
	pSerial->Deserialize( iVersion );

	CStringANSI8 strVersionUTF8;
	strVersionUTF8 = g_pApp->GetApplicationVersion().GetString();
	pSerial->DeserializeANSI8( strVersionUTF8 );

	if( DeserializeChecksum( pSerial ) )
	{
		DeserializeHeader( pSerial );
		DeserializeBody( pSerial );
		m_bGoodChecksum = true;
		return true;
	}
	return false;
}

bool CUnitset::DeserializeChecksum( CSerial* pSerial )
{
	char cVersion = 1;
	pSerial->Deserialize( cVersion );

	// Some randomization (to hinder cracking)
	CStringANSI8 strRandomizerStringANSI8_InFile;
	pSerial->DeserializeANSI8( strRandomizerStringANSI8_InFile );

	// Add a header checksum (based on randomizer + header)
	//CStringANSI8 strHeaderChecksumUTF8 = CBCString::GetChecksum( strRandomizerStringANSI8, pSerial->GetRawData(), iStartHeader, iEndHeader );
	CStringANSI8 strHeaderChecksumUTF8_InFile;
	pSerial->DeserializeANSI8( strHeaderChecksumUTF8_InFile );

	// Add a body checksum (based on randomizer + body)
	//CStringANSI8 strBodyChecksumUTF8 = CBCString::GetChecksum( strRandomizerStringANSI8, pSerial->GetRawData(), iStartBody, iEndBody );
	CStringANSI8 strBodyChecksumUTF8_InFile;
	pSerial->DeserializeANSI8( strBodyChecksumUTF8_InFile );

	// Add a header+body checksum (based on HeaderChecksum + BodyChecksum)
	//CStringANSI8 strFullChecksumUTF8 = CBCString::GetChecksum( strHeaderChecksumUTF8, strBodyChecksumUTF8 );
	CStringANSI8 strFullChecksumUTF8_InFile;
	pSerial->DeserializeANSI8( strFullChecksumUTF8_InFile );

	long iBeginningOfBody = pSerial->ExtractLong();

	long iBeginningOfHeader = pSerial->GetCurrentLocation();
	long iEndOfBody = pSerial->GetUsedSize()-1;

	//CStringANSI8 strHeaderChecksumUTF8_Calculated;
	//CStringANSI8 strBodyChecksumUTF8_Calculated;
	//CStringANSI8 strFullChecksumUTF8_Calculated;
	CStringANSI8 strHeaderChecksumUTF8_Calculated = CBCString::GetChecksum( strRandomizerStringANSI8_InFile, pSerial->GetRawData(), iBeginningOfHeader, iBeginningOfBody-1 );
	CStringANSI8 strBodyChecksumUTF8_Calculated   = CBCString::GetChecksum( strRandomizerStringANSI8_InFile, pSerial->GetRawData(), iBeginningOfBody, iEndOfBody );
	CStringANSI8 strFullChecksumUTF8_Calculated   = CBCString::GetChecksum( strHeaderChecksumUTF8_Calculated, strBodyChecksumUTF8_Calculated );

	// The demo doesn't use checksums
	#ifdef DEMO
	m_bGoodChecksum = true;
	return true;
	#endif DEMO

	if( strHeaderChecksumUTF8_InFile != strHeaderChecksumUTF8_Calculated ||
		strBodyChecksumUTF8_InFile   != strBodyChecksumUTF8_Calculated ||
		strFullChecksumUTF8_InFile   != strFullChecksumUTF8_Calculated )
	{
		m_bGoodChecksum = false;
		return false;
	}
	m_bGoodChecksum = true;
	return true;
}

void CUnitset::DeserializeHeader( CSerial* pSerial )
{
	short sVersion = 1;
	pSerial->Deserialize( sVersion );

	if( sVersion == 1 )
	{
		pSerial->DeserializeANSI8( m_strFileUID );
		pSerial->DeserializeANSI8( m_strTitle );
		pSerial->DeserializeANSI8( m_strAuthor );
		pSerial->DeserializeANSI8( m_strDerivedFromAuthor );
		pSerial->DeserializeANSI8( m_strVersionAsTimestamp );
	}
	if( sVersion >= 2 )
	{
		pSerial->DeserializeUnicode( m_strFileUID );
		pSerial->DeserializeUnicode( m_strTitle );
		pSerial->DeserializeUnicode( m_strAuthor );
		pSerial->DeserializeUnicode( m_strDerivedFromAuthor );
		pSerial->DeserializeUnicode( m_strVersionAsTimestamp );
	}

	long iCount = 0;
	//iCount = m_UnitTemplateList.GetCount();
	pSerial->Deserialize( iCount );
	//iCount = m_TechnologyList.GetCount();
	pSerial->Deserialize( iCount );
	//iCount = m_BuildingDescriptionList.GetCount();
	pSerial->Deserialize( iCount );

	if( sVersion == 1 )
	{
		pSerial->DeserializeANSI8( m_strDescription );
		pSerial->DeserializeANSI8( m_strUnitSummary );
		pSerial->DeserializeANSI8( m_strTechSummary );
		pSerial->DeserializeANSI8( m_strBuildingSummary );
		pSerial->DeserializeANSI8( m_strTerrainSummary );
	}
	if( sVersion >= 2 )
	{
		pSerial->DeserializeUnicode( m_strDescription );
		pSerial->DeserializeUnicode( m_strUnitSummary );
		pSerial->DeserializeUnicode( m_strTechSummary );
		pSerial->DeserializeUnicode( m_strBuildingSummary );
		pSerial->DeserializeUnicode( m_strTerrainSummary );
	}

	pSerial->Deserialize( iCount );
	for( long i=0; i<iCount; i++ )
	{
		//CString strUnitsubset = m_UnitsubsetList.GetNext( pos );
		//pSerial->DeserializeANSI8( strUnitsubset );
		/*
		CStringANSI8 strUnitsubsetANSI8;
		pSerial->DeserializeANSI8( strUnitsubsetANSI8 );
		CString strUnitsubset; strUnitsubset = strUnitsubsetANSI8;
		*/
		CString strUnitsubset;
		if( sVersion == 1 )
		{
			pSerial->DeserializeANSI8( strUnitsubset );
		}
		if( sVersion >= 2 )
		{
			pSerial->DeserializeUnicode( strUnitsubset );
		}
		m_UnitsubsetList.AddTail( strUnitsubset );
	}

	// 
	// Version 3
	if( sVersion >= 3 )
	{
		long iUnitTemplateImages = 0;
		pSerial->Deserialize( iUnitTemplateImages );
		for( long i=0; i<iUnitTemplateImages; i++ )
		{
			CString strUnitTemplateImage;
			pSerial->DeserializeUnicode( strUnitTemplateImage );
			m_UnitTemplateImages.AddTail( strUnitTemplateImage );
		}
	}
/*
	//
	CString strData;
	strData += ANSI8("<FileUID>") + CStringANSI8( m_strFileUID ) + ANSI8("</FileUID>\n");
	strData += ANSI8("<Title>") + CStringANSI8( m_strTitle ) + ANSI8("</Title>\n");
	strData += ANSI8("<Author>") + CStringANSI8( m_strAuthor ) + ANSI8("</Author>\n");
	strData += ANSI8("<DerivedFromAuthor>") + CStringANSI8( m_strDerivedFromAuthor ) + ANSI8("</DerivedFromAuthor>\n");
	//strData += "<UnitsetUniqueId>" + m_strUnitsetUniqueId + "</UnitsetUniqueId>\n";
	strData += ANSI8("<Version>") + CStringANSI8( m_strVersionAsTimestamp ) + ANSI8("</Version>\n");
	//strData += "<Version>" + g_pApp->GetCurrentTimeSortString() + "</Version>\n";

	strData += ANSI8("<AppVersion>") + CStringANSI8( g_pApp->GetApplicationVersion().GetString() ) + ANSI8("</AppVersion>\n");

	strData += ANSI8("<UnitCount>") + CBCStringANSI8::LongAsString( m_UnitTemplateList.GetCount() ) + ANSI8("</UnitCount>\n");
	strData += ANSI8("<TechCount>") + CBCStringANSI8::LongAsString( m_TechnologyList.GetCount() ) + ANSI8("</TechCount>\n");
	strData += ANSI8("<BuildingCount>") + CBCStringANSI8::LongAsString( m_BuildingDescriptionList.GetCount() ) + ANSI8("</BuildingCount>\n");

	strData += ANSI8("<Description>") + CStringANSI8( m_strDescription ) + ANSI8("</Description>\n");

	//strData += "<Summary>" + m_strWebpageSummary + "</Summary>";
	strData += ANSI8("<UnitSummary>") + CStringANSI8( m_strUnitSummary ) + ANSI8("</UnitSummary>\n");
	strData += ANSI8("<TechSummary>") + CStringANSI8( m_strTechSummary ) + ANSI8("</TechSummary>\n");
	strData += ANSI8("<BuildingSummary>") + CStringANSI8( m_strBuildingSummary ) + ANSI8("</BuildingSummary>\n");
	strData += ANSI8("<TerrainSummary>") + CStringANSI8( m_strTerrainSummary ) + ANSI8("</TerrainSummary>\n");

	strData += ANSI8("<Unitsubsets>\n");
	POSITION pos = m_UnitsubsetList.GetHeadPosition();
	while( pos )
	{
		CString strUnitsubset = m_UnitsubsetList.GetNext( pos );
		strData += ANSI8("<Unitsubset>") + CStringANSI8( strUnitsubset ) + ANSI8("</Unitsubset>\n");
	}
	strData += ANSI8("</Unitsubsets>\n");
*/
}

void CUnitset::DeserializeBody( CSerial* pSerial )
{
	long iCount = 0;

	long iVersion = 0;
	pSerial->Deserialize( iVersion );

	if( iVersion >= 3 )
	{
		pSerial->Deserialize( m_fCombatRandomness01 ); // Version 3
	}
	else
	{
		SetCombatRandomness01( 0.5f );
	}
	//CCombatManager::SetupRandomTable( 0.0f );

	//
	// Unitsubsets and the bonuses associated with each (move code from below)
	//
	//long iPasses = m_UnitsubsetList.GetCount() + 1;
	long iPasses;
	pSerial->Deserialize( iPasses );
	for( long iPass=0; iPass<iPasses; iPass++ )
	{
		//CStringANSI8 strUnitsubset = "";
		CString strUnitsubset = _T("");
		if( iPass == 0 ){}
		else
		{
			if( iVersion == 1 )
			{
				pSerial->DeserializeANSI8( strUnitsubset );
			}
			if( iVersion >= 2 )
			{
				pSerial->DeserializeUnicode( strUnitsubset );
			}
			//m_UnitsubsetList.AddTail( strUnitsubset );
			//strUnitsubset = m_UnitsubsetList.GetAt( m_UnitsubsetList.FindIndex( iPass-1 ) );
			//pSerial->SerializeANSI8( strUnitsubset );
		}
		/*
		CString strUnitsubset = _T("");
		if( iPass == 0 )
		{
			strData += ANSI8("<AllSubsets>");
		}
		else
		{
			strUnitsubset = m_UnitsubsetList.GetAt( m_UnitsubsetList.FindIndex( iPass-1 ) );
			strData += ANSI8("<Subset>\n");
			strData += ANSI8("<Name>") + CStringANSI8( strUnitsubset ) + ANSI8("</Name>\n");
		}
		*/
		CString strFreeTech;
		bool bFound = true;
		while( bFound )
		{
			if( iVersion == 1 )
			{
				pSerial->DeserializeANSI8( strFreeTech );
			}
			if( iVersion >= 2 )
			{
				pSerial->DeserializeUnicode( strFreeTech );
			}

			if( strFreeTech != _T("") )
			{
				CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, strFreeTech );
				m_InitialFreeTechnologyList.AddTail( pVal );
			}
			else
			{
				bFound = false;
			}
		}
		/*
		pos = m_InitialFreeTechnologyList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeTechnologyList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				pSerial->SerializeANSI8( pUnitsubsetValue->m_strValue );
			}
		}
		pSerial->SerializeANSI8( "" );
		*/
		/*
		strData += ANSI8("<Free>\n");
		pos = m_InitialFreeTechnologyList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeTechnologyList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Tech>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Tech>\n");
			}
		}
		*/
		CString strFreeUnit;
		bFound = true;
		while( bFound )
		{
			if( iVersion == 1 )
			{
				pSerial->DeserializeANSI8( strFreeUnit );
			}
			if( iVersion >= 2 )
			{
				pSerial->DeserializeUnicode( strFreeUnit );
			}

			if( strFreeUnit != _T("") )
			{
				CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, strFreeUnit );
				m_InitialFreeUnitCoastalCityList.AddTail( pVal );
			}
			else
			{
				bFound = false;
			}
		}
		/*
		pos = m_InitialFreeUnitCoastalCityList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitCoastalCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				pSerial->SerializeANSI8( pUnitsubsetValue->m_strValue );
			}
		}
		pSerial->SerializeANSI8( "" );
		*/
		/*
		pos = m_InitialFreeUnitCoastalCityList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitCoastalCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Unit-Coastal>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Unit-Coastal>\n");
			}
		}
		*/
		CString strFreeUnitLandlocked;
		bFound = true;
		while( bFound )
		{
			if( iVersion == 1 )
			{
				pSerial->DeserializeANSI8( strFreeUnitLandlocked );
			}
			if( iVersion >= 2 )
			{
				pSerial->DeserializeUnicode( strFreeUnitLandlocked );
			}

			if( strFreeUnitLandlocked != _T("") )
			{
				CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, strFreeUnitLandlocked );
				m_InitialFreeUnitLandlockedCityList.AddTail( pVal );
			}
			else
			{
				bFound = false;
			}
		}
		/*
		pos = m_InitialFreeUnitLandlockedCityList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitLandlockedCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				pSerial->SerializeANSI8( pUnitsubsetValue->m_strValue );
			}
		}
		pSerial->SerializeANSI8( "" );
		*/
		/*
		pos = m_InitialFreeUnitLandlockedCityList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitLandlockedCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Unit-Landlocked>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Unit-Landlocked>\n");
			}
		}
		strData += ANSI8("</Free>\n");
		*/
		CString strCanBuildUnit;
		bFound = true;
		while( bFound )
		{
			if( iVersion == 1 )
			{
				pSerial->DeserializeANSI8( strCanBuildUnit );
			}
			if( iVersion >= 2 )
			{
				pSerial->DeserializeUnicode( strCanBuildUnit );
			}

			if( strCanBuildUnit != _T("") )
			{
				CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, strCanBuildUnit );
				m_InitialCanBuildUnitList.AddTail( pVal );
			}
			else
			{
				bFound = false;
			}
		}
		/*
		pos = m_InitialCanBuildUnitList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				pSerial->SerializeANSI8( pUnitsubsetValue->m_strValue );
			}
		}
		pSerial->SerializeANSI8( "" );
		*/
		/*
		strData += ANSI8("<InitialCanBuild>");
		pos = m_InitialCanBuildUnitList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Unit>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Unit>\n");
			}
		}
		*/
		CString strCanBuildBuilding;
		bFound = true;
		while( bFound )
		{
			if( iVersion == 1 )
			{
				pSerial->DeserializeANSI8( strCanBuildBuilding );
			}
			if( iVersion >= 2 )
			{
				pSerial->DeserializeUnicode( strCanBuildBuilding );
			}

			if( strCanBuildBuilding != _T("") )
			{
				CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, strCanBuildBuilding );
				m_InitialCanBuildBuildingList.AddTail( pVal );
			}
			else
			{
				bFound = false;
			}
		}

		if( iVersion >= 6 )
		{
			CString strCanBuildAirfieldImprovement;
			bFound = true;
			while( bFound )
			{
				pSerial->DeserializeUnicode( strCanBuildAirfieldImprovement );
				if( strCanBuildAirfieldImprovement != _T("") )
				{
					CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, strCanBuildAirfieldImprovement );
					m_InitialCanBuildAirfieldImprovementList.AddTail( pVal );
				}
				else
				{
					bFound = false;
				}
			}
		}

		/*
		pos = m_InitialCanBuildBuildingList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				pSerial->SerializeANSI8( pUnitsubsetValue->m_strValue );
			}
		}
		pSerial->SerializeANSI8( "" );
		*/
		/*
		pos = m_InitialCanBuildBuildingList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Building>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Building>\n");
			}
		}
		strData += ANSI8("</InitialCanBuild>");
		*/
		/*
		pos = m_AllowResearchList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_AllowResearchList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += "<ResearchAllowed>" + pUnitsubsetValue->m_strValue + "</ResearchAllowed>\n";
			}
		}
		*/

		//if( iPass == 0 ){ strData += ANSI8("</AllSubsets>\n"); }
		//else{ strData += ANSI8("</Subset>\n"); }
	}

	// Version 4
	if( iVersion >= 4 )
	{
		long iItemCount = 0;
		pSerial->Deserialize( iItemCount );
		for( long i=0; i<iItemCount; i++ )
		{
			CUnitsubsetStringLongValue* p = new CUnitsubsetStringLongValue();
			pSerial->DeserializeUnicode( p->m_strUnitsubset );
			pSerial->DeserializeUnicode( p->m_strValue );
			pSerial->Deserialize( p->m_iValue );
			m_InitialResources.AddTail( p );
		}
	}
	else
	{
		// Setup initial resources
		POSITION pos = m_UnitsubsetList.GetHeadPosition();
		while( pos )
		{
			CString strUnitsubset = m_UnitsubsetList.GetNext( pos );
			m_InitialResources.AddTail( new CUnitsubsetStringLongValue( strUnitsubset, _T("Money"), 100 ) );
			m_InitialResources.AddTail( new CUnitsubsetStringLongValue( strUnitsubset, _T("Iron"), 100 ) );
			m_InitialResources.AddTail( new CUnitsubsetStringLongValue( strUnitsubset, _T("Oil"), 100 ) );
			m_InitialResources.AddTail( new CUnitsubsetStringLongValue( strUnitsubset, _T("Food"), 100 ) );
		}
	}


	//strData += ANSI8("</UnitSubsets>\n");

	// Write "AllowTechnology" information
	/*
	strData += "<AllowTechnology>\n";
	pos = m_Allow_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CItemAndUnitsubset* pItemAndUnitsubset = m_Allow_TechnologyList.GetNext( pos );
		//pItemAndUnitsubset->AppendDataToXMLString( strData );
	}
	strData += "</AllowTechnology>\n";
	*/
	// Write "AllowUnit" information
	/*A
	strData += "<AllowUnit>\n";
	pos = m_Allow_UnitList.GetHeadPosition();
	while( pos )
	{
		CItemAndUnitsubset* pItemAndUnitsubset = m_Allow_UnitList.GetNext( pos );
		//pItemAndUnitsubset->AppendDataToXMLString( strData );
	}
	strData += "</AllowUnit>\n";
	*/

	// Write "AllowBuilding" information
	/*
	strData += "<AllowBuilding>\n";
	pos = m_Allow_BuildingList.GetHeadPosition();
	while( pos )
	{
		CItemAndUnitsubset* pItemAndUnitsubset = m_Allow_BuildingList.GetNext( pos );
		//pItemAndUnitsubset->AppendDataToXMLString( strData );
	}
	strData += "</AllowBuilding>\n";
	*/

	//
	// Animations used by this unitset
	//
		// Should I derive this information from the UnitTemplate information?
		

	//
	// Basic Combat/Movement Information
	//
		// Combat Unit Types
		//iCount = m_CombatUnitTypes.GetCount();
		pSerial->Deserialize( iCount );
		//pos = m_CombatUnitTypes.GetHeadPosition();
		//while( pos )
		for( long i=0; i<iCount; i++ )
		{
			//CCombatUnitType* pCombatUnitType = m_CombatUnitTypes.GetNext( pos );
			//pCombatUnitType->Serialize( pSerial );
			CCombatUnitType* pCombatUnitType = new CCombatUnitType();
			pCombatUnitType->Deserialize( pSerial );
			AddCombatUnitType( pCombatUnitType );
			//m_CombatUnitTypes.AddTail( pCombatUnitType );
		}
		// If loading an old version, then we have to switch the docked/prone data
		POSITION pos = m_CombatUnitTypes.GetHeadPosition();
		while( pos )
		{
			CCombatUnitType* pCombatUnitType = m_CombatUnitTypes.GetNext( pos );
			if( pCombatUnitType->m_strLandedOrDockedCombatType_Old != _T("") )
			{
				CCombatUnitType* pOtherCombatUnitType = GetCombatUnitTypeByExternalName( pCombatUnitType->m_strLandedOrDockedCombatType_Old );
				if( pOtherCombatUnitType )
				{
					pCombatUnitType->m_iLandedOrDockedCombatType = pOtherCombatUnitType->m_iCombatUnitType;//GetCombatUnitTypeByExternalName( m_strLandedOrDockedCombatType_Old );
				}				
			}
		}
		// Make sure to strip-out invalid prone/docked values
		pos = m_CombatUnitTypes.GetHeadPosition();
		while( pos )
		{
			CCombatUnitType* pCombatUnitType = m_CombatUnitTypes.GetNext( pos );
			CCombatUnitType* pDockedProneType = GetCombatUnitType( pCombatUnitType->m_iLandedOrDockedCombatType );
			if( pDockedProneType == NULL ) // Doesn't exist, so reset it
			{
				//pCombatUnitType->m_strLandedOrDockedCombatType = pCombatUnitType->m_strName;
				pCombatUnitType->m_iLandedOrDockedCombatType = pCombatUnitType->m_iCombatUnitType;
			}
		}
	/*
		// Combat Unit Types
		strData += ANSI8("<CombatUnitTypes>\n");
		pos = m_CombatUnitTypes.GetHeadPosition();
		while( pos )
		{
			//m_CombatUnitTypes.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</CombatUnitTypes>\n");
	*/
		// Movement Unit Types
		//iCount = m_MovementUnitTypes.GetCount();
		pSerial->Deserialize( iCount );
		//pos = m_MovementUnitTypes.GetHeadPosition();
		//while( pos )
		for( long i=0; i<iCount; i++ )
		{
			//CMovementUnitType* pMovementUnitType = m_MovementUnitTypes.GetNext( pos );
			//pMovementUnitType->Serialize( pSerial );
			CMovementUnitType* pMovementUnitType = new CMovementUnitType();
			pMovementUnitType->Deserialize( pSerial );
			AddMovementUnitType( pMovementUnitType ); // This will assign a MovementUnitType number
			//m_MovementUnitTypes.AddTail( pMovementUnitType );
		}
	/*
		// Movement Unit Types
		strData += ANSI8("<MovementUnitTypes>\n");
		pos = m_MovementUnitTypes.GetHeadPosition();
		while( pos )
		{
			//m_MovementUnitTypes.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</MovementUnitTypes>\n");
	*/

	//
	// Categories
	//
		//iCount = m_UnitCategories.GetCount();
		//pSerial->Serialize( iCount );
		pSerial->Deserialize( iCount );
		//pos = m_UnitCategories.GetHeadPosition();
		//while( pos )
		for( long i=0; i<iCount; i++ )
		{
			//CUnitCategory* pUnitCategory = m_UnitCategories.GetNext( pos );
			//pUnitCategory->Serialize( pSerial );
			CUnitCategory* pUnitCategory = new CUnitCategory();
			pUnitCategory->Deserialize( pSerial );
			m_UnitCategories.AddTail( pUnitCategory );
		}

		/*
		strData += ANSI8("<UnitCategories>\n");
		pos = m_UnitCategories.GetHeadPosition();
		while( pos )
		{
			//m_UnitCategories.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</UnitCategories>\n");
		*/

	//
	// City/Resource/Airfield View Ranges
	//
		// City Description
		pSerial->Deserialize( m_fCityDefaultViewRange );
		//iCount = GetCityViewRangeList()->GetCount();
		pSerial->Deserialize( iCount );
		//pos = GetCityViewRangeList()->GetHeadPosition();
		//while( pos )
		for( long i=0; i<iCount; i++ )
		{
			//CViewRange* pViewRange = GetCityViewRangeList()->GetNext( pos );
			//pSerial->SerializeANSI8( pViewRange->m_strUnitTag );
			//pSerial->Serialize( pViewRange->m_fViewRange );
			CViewRange* pViewRange = new CViewRange();
			if( iVersion == 1 )
			{
				pSerial->DeserializeANSI8( pViewRange->m_strUnitTag );
			}
			if( iVersion >= 2 )
			{
				pSerial->DeserializeUnicode( pViewRange->m_strUnitTag );
			}
			pSerial->Deserialize( pViewRange->m_fViewRange );
			GetCityViewRangeList()->AddTail( pViewRange );
		}
		pSerial->Deserialize( m_fCityOilConsumption );
		pSerial->Deserialize( m_fCityFoodConsumption );

		if( iVersion >= 5 )
		{
			pSerial->Deserialize( m_fCityGroundUnitRepairRate );
			pSerial->Deserialize( m_fCitySeaUnitRepairRate );
			pSerial->Deserialize( m_fCityAirUnitRepairRate );
		}
		/*
		// City Description
		strData += ANSI8("<CityDescription>\n");
		//strData += "<DefaultViewRange>" + CBCString::FloatAsString(CCity::GetDefaultViewRange2()) + "</DefaultViewRange>\n";
		strData += ANSI8("<DefaultViewRange>") + CBCStringANSI8::FloatAsString(m_fCityDefaultViewRange) + ANSI8("</DefaultViewRange>\n");
		//pos = CCity::GetViewRangeList()->GetHeadPosition();
		pos = GetCityViewRangeList()->GetHeadPosition();
		while( pos )
		{
			CViewRange* pViewRange = GetCityViewRangeList()->GetNext( pos );
			strData += ANSI8("<SpecialViewRange>\n");
			strData += ANSI8("<UnitTag>") + CStringANSI8( pViewRange->m_strUnitTag ) + ANSI8("</UnitTag>");
			strData += ANSI8("<Range>") + CBCStringANSI8::FloatAsString(pViewRange->m_fViewRange) + ANSI8("</Range>");
			strData += ANSI8("</SpecialViewRange>\n");
		}
		strData += ANSI8("<OilConsumption>") + CBCStringANSI8::FloatAsString(m_fCityOilConsumption) + ANSI8("</OilConsumption>\n");
		strData += ANSI8("<FoodConsumption>") + CBCStringANSI8::FloatAsString(m_fCityFoodConsumption) + ANSI8("</FoodConsumption>\n");
		strData += ANSI8("</CityDescription>\n");
		*/

		// Resource Description
		pSerial->Deserialize( m_fResourceDefaultViewRange );
		//iCount = GetResourceViewRangeList()->GetCount();
		pSerial->Deserialize( iCount );
		//pos = GetResourceViewRangeList()->GetHeadPosition();
		//while( pos )
		for( long i=0; i<iCount; i++ )
		{
			//GetResourceViewRangeList()->GetNext( pos );
			CViewRange* pViewRange = new CViewRange();
			if( iVersion == 1 )
			{
				pSerial->DeserializeANSI8( pViewRange->m_strUnitTag );
			}
			if( iVersion >= 2 )
			{
				pSerial->DeserializeUnicode( pViewRange->m_strUnitTag );
			}
			pSerial->Deserialize( pViewRange->m_fViewRange );
			GetResourceViewRangeList()->AddTail( pViewRange );
		}
		/*
		strData += ANSI8("<ResourceDescription>\n");
		strData += ANSI8("<DefaultViewRange>") + CBCStringANSI8::FloatAsString(m_fResourceDefaultViewRange) + ANSI8("</DefaultViewRange>\n");
		pos = GetResourceViewRangeList()->GetHeadPosition();
		while( pos )
		{
			CViewRange* pViewRange = GetResourceViewRangeList()->GetNext( pos );
			strData += ANSI8("<SpecialViewRange>\n");
			strData += ANSI8("<UnitTag>") + CStringANSI8( pViewRange->m_strUnitTag ) + ANSI8("</UnitTag>");
			strData += ANSI8("<Range>") + CBCStringANSI8::FloatAsString(pViewRange->m_fViewRange) + ANSI8("</Range>");
			strData += ANSI8("</SpecialViewRange>\n");
		}
		strData += ANSI8("</ResourceDescription>\n");
		*/

		// Airfield Description
		//pSerial->Deserialize( m_fAirfieldConstructionCost );
		if( iVersion < 9 )
		{
			float fAirfieldConstructionCost = 0.0f;
			pSerial->Deserialize( fAirfieldConstructionCost );

			CStringAndFloat* pCost = new CStringAndFloat();
			pCost->m_strValue = _T("Money");
			pCost->m_fValue = fAirfieldConstructionCost;
			m_AirfieldConstructionCostList.AddTail( pCost );
		}
		if( iVersion >= 9 )
		{
			/*
			// Airfield Maintenance Costs - Version 9
			iCount = m_AirfieldConstructionCostList.GetCount();
			pSerial->Serialize( iCount );
			pos = m_AirfieldConstructionCostList.GetHeadPosition();
			while( pos )
			{
				CStringAndFloat* pCost = m_AirfieldConstructionCostList.GetNext( pos );
				pSerial->SerializeUnicode( pCost->m_strValue );
				pSerial->Serialize( pCost->m_fValue );
			}
			*/
			pSerial->Deserialize( iCount );
			for( long i=0; i<iCount; i++ )
			{
				CStringAndFloat* pCost = new CStringAndFloat();
				pSerial->DeserializeUnicode( pCost->m_strValue );
				pSerial->Deserialize( pCost->m_fValue );
				m_AirfieldConstructionCostList.AddTail( pCost );
			}
		}

		pSerial->Deserialize( m_fAirfieldDefaultViewRange );
		//iCount = GetAirfieldViewRangeList()->GetCount();
		pSerial->Deserialize( iCount );
		//pos = GetAirfieldViewRangeList()->GetHeadPosition();
		//while( pos )
		for( long i=0; i<iCount; i++ )
		{
			//CViewRange* pViewRange = GetAirfieldViewRangeList()->GetNext( pos );
			CViewRange* pViewRange = new CViewRange();
			if( iVersion == 1 )
			{
				pSerial->DeserializeANSI8( pViewRange->m_strUnitTag );
			}
			if( iVersion >= 2 )
			{
				pSerial->DeserializeUnicode( pViewRange->m_strUnitTag );
			}
			pSerial->Deserialize( pViewRange->m_fViewRange );
			m_AirfieldViewRangeList.AddTail( pViewRange );
		}

		// Airfield Maintenance Costs - Version 8
		if( iVersion >= 8 && iVersion <= 9 )
		{
			pSerial->Deserialize( iCount );
			for( long i=0; i<iCount; i++ )
			{
				CStringAndFloat* pMaintenanceCost = new CStringAndFloat();
				pSerial->DeserializeUnicode( pMaintenanceCost->m_strValue );
				pSerial->Deserialize( pMaintenanceCost->m_fValue );
				pMaintenanceCost->m_fValue *= -1.0f;
				m_AirfieldProductionConsumptionList.AddTail( pMaintenanceCost );
			}
		}
		if( iVersion >= 10 )
		{
			pSerial->Deserialize( iCount );
			for( long i=0; i<iCount; i++ )
			{
				CStringAndFloat* pProductionConsumption = new CStringAndFloat();
				pSerial->DeserializeUnicode( pProductionConsumption->m_strValue );
				pSerial->Deserialize( pProductionConsumption->m_fValue );
				m_AirfieldProductionConsumptionList.AddTail( pProductionConsumption );
			}
		}

		// UnitDefault View Range
		pSerial->Deserialize( iCount );
		for( long i=0; i<iCount; i++ )
		{
			//CViewRange* pViewRange = m_UnitDefaultViewRangeList.GetNext( pos );
			CViewRange* pViewRange = new CViewRange();
			if( iVersion == 1 )
			{
				pSerial->DeserializeANSI8( pViewRange->m_strUnitTag );
			}
			if( iVersion >= 2 )
			{
				pSerial->DeserializeUnicode( pViewRange->m_strUnitTag );
			}
			pSerial->Deserialize( pViewRange->m_fViewRange );
			m_UnitDefaultViewRangeList.AddTail( pViewRange );
		}
		/*
		strData += ANSI8("<UnitDefaults>\n");
		pos = m_UnitDefaultViewRangeList.GetHeadPosition();
		while( pos )
		{
			CViewRange* pViewRange = m_UnitDefaultViewRangeList.GetNext( pos );
			strData += ANSI8("<SpecialViewRange>\n");
			strData += ANSI8("<UnitTag>") + CStringANSI8( pViewRange->m_strUnitTag ) + ANSI8("</UnitTag>");
			strData += ANSI8("<Range>") + CBCStringANSI8::FloatAsString(pViewRange->m_fViewRange) + ANSI8("</Range>");
			strData += ANSI8("</SpecialViewRange>\n");
		}
		strData += ANSI8("</UnitDefaults>\n");
		*/

	//
	// Setup BuildOptions
	//
		// Add as a Build Option
		CBuildOption* pBuildOption = new CBuildOption();
		pBuildOption->SetBuildTargetToMoney();
		pBuildOption->SetBuildOptionSet( this );
		this->AddBuildOption( pBuildOption );

	//
	// Unit Templates
	//
		//iCount = m_UnitTemplateList.GetCount();
		pSerial->Deserialize( iCount );
		//pos = m_UnitTemplateList.GetHeadPosition();
		//while( pos )
		long iCurrentUnitTemplateIndex = 0;
		for( long i=0; i<iCount; i++ )
		{
			//CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
			//pUnitTemplate->Serialize( pSerial );
			CUnitTemplateB* pUnitTemplate = new CUnitTemplateB( this );
			pUnitTemplate->Deserialize( pSerial );
			pUnitTemplate->SetIndex( iCurrentUnitTemplateIndex );
			iCurrentUnitTemplateIndex++;
			m_UnitTemplateList.AddTail( pUnitTemplate );

			// Check the data
			#ifdef _DEBUG
			{
				ASSERT( pUnitTemplate->GetCombatUnitTypeLong() > 0 );
				POSITION pos = pUnitTemplate->GetAttackVsList()->GetHeadPosition();
				while( pos )
				{
					CAttackVs* pAttackVs = pUnitTemplate->GetAttackVsList()->GetNext( pos );
					ASSERT( pAttackVs->m_iAttackVsCombatUnitType != 0 );
				}

				// Check to make sure this unit's combat unit type is in the list
				bool bMyCombatTypeIsInTheList = false;
				pos = m_CombatUnitTypes.GetHeadPosition();
				while( pos )
				{
					CCombatUnitType* pCombatUnitType = m_CombatUnitTypes.GetNext( pos );
					//if( pCombatUnitType->m_strName == pUnitTemplate->GetCombatUnitTypeString() )
					if( pCombatUnitType->m_iCombatUnitType == pUnitTemplate->GetCombatUnitTypeLong() )
					{
						bMyCombatTypeIsInTheList = true;
					}
					//CAttackVs* pAttackVs = pUnitTemplate->GetAttackVs( pCombatUnitType->m_strName );
					CAttackVs* pAttackVs = pUnitTemplate->GetAttackVsCombatUnitType( pCombatUnitType->m_iCombatUnitType );
					if( pAttackVs == NULL )
					{
						// I don't have an AttackVs value against this combat type
						ASSERT( false );
					}
				}
				ASSERT( bMyCombatTypeIsInTheList );
			}
			#endif _DEBUG

			// Add as a Build Option
			CBuildOption* pBuildOption = new CBuildOption();
			pBuildOption->SetBuildOptionSet( this );
			pBuildOption->SetBuildTargetToUnit( pUnitTemplate );
			this->AddBuildOption( pBuildOption );
		}
		SetNumValuesOfUnitTemplates();
		CalculateWhichUnitsAreSubmarines();

		/*
		strData += ANSI8("<Units>\n");
		pos = m_UnitTemplateList.GetHeadPosition();
		while( pos )
		{
			//m_UnitTemplateList.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</Units>\n");
		*/

	//
	// Buildings
	//
		//iCount = m_BuildingDescriptionList.GetCount();
		pSerial->Deserialize( iCount );
		//pos = m_BuildingDescriptionList.GetHeadPosition();
		//while( pos )
		for( long i=0; i<iCount; i++ )
		{
			//CBuildingDescription* pBuildingDesc = m_BuildingDescriptionList.GetNext( pos );
			//pBuildingDesc->Serialize( pSerial );
			CBuildingDescription* pBuildingDesc = new CBuildingDescription( this );
			pBuildingDesc->Deserialize( pSerial );
			m_BuildingDescriptionList.AddTail( pBuildingDesc );
			//m_BuildingDescriptionList.GetNext( pos )->AppendDataToXMLString( strData );

			// Add as a Build Option
			CBuildOption* pBuildOption = new CBuildOption();
			pBuildOption->SetBuildOptionSet( this );
			pBuildOption->SetBuildTargetToBuilding( pBuildingDesc );
			this->AddBuildOption( pBuildOption );
		}
		/*
		strData += ANSI8("<Buildings>\n");
		pos = m_BuildingDescriptionList.GetHeadPosition();
		while( pos )
		{
			//m_BuildingDescriptionList.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</Buildings>\n");
		*/
	//
	// Airfield Improvements
	//
		if( iVersion >= 6 )
		{
			pSerial->Deserialize( iCount );
			for( long i=0; i<iCount; i++ )
			{
				CAirfieldImprovement* pImprovement = new CAirfieldImprovement( this );
				pImprovement->Deserialize( pSerial );
				m_AirfieldImprovementList.AddTail( pImprovement );
			}
			/*
			iCount = m_AirfieldImprovementList.GetCount();
			pSerial->Serialize( iCount );
			pos = m_AirfieldImprovementList.GetHeadPosition();
			while( pos )
			{
				CAirfieldImprovement* pImprove = m_AirfieldImprovementList.GetNext( pos );
				pImprove->Serialize( pSerial );
			}
			*/
		}

	//
	// Militia units
	//
		//iCount = m_InitialMilitiaUnitList.GetCount();
		pSerial->Deserialize( iCount );
		//pos = m_InitialMilitiaUnitList.GetHeadPosition();
		//while( pos )
		for( long i=0; i<iCount; i++ )
		{
			//CString strMilitia = m_InitialMilitiaUnitList.GetNext( pos );
			//pSerial->SerializeANSI8( strMilitia );
			CString strMilitia;
			if( iVersion == 1 )
			{
				pSerial->DeserializeANSI8( strMilitia );
			}
			if( iVersion >= 2 )
			{
				pSerial->DeserializeUnicode( strMilitia );
			}
			m_InitialMilitiaUnitList.AddTail( strMilitia );
		}
		/*
		strData += ANSI8("<Militia>\n");
		pos = m_InitialMilitiaUnitList.GetHeadPosition();
		while( pos )
		{
			CString strMilitia = m_InitialMilitiaUnitList.GetNext( pos );
			strData += ANSI8("<Unit>") + CStringANSI8( strMilitia ) + ANSI8("</Unit>\n");
		}
		strData += ANSI8("</Militia>\n");
		*/

	//
	// Combat Experience
	//
	if( iVersion >= 7 )
	{
		pSerial->Deserialize( m_fUnitAgeCombatExperience );
		for( long i=0; i<4; i++ )
		{
			pSerial->Deserialize( m_fCombatLevelExperience[i] );
			pSerial->Deserialize( m_fCombatLevelMultiplier[i] );
			pSerial->DeserializeUnicode( m_strCombatLevelName[i] );
		}
	}

	//
	// Technology
	//
		//iCount = m_TechnologyList.GetCount();
		pSerial->Deserialize( iCount );
		//pos = m_TechnologyList.GetHeadPosition();
		//while( pos )
		for( long i=0; i<iCount; i++ )
		{
			//CTechnologyDesc* pTechDesc = m_TechnologyList.GetNext( pos );
			//pTechDesc->Serialize( pSerial );
			//m_TechnologyList.GetNext( pos )->AppendDataToXMLString( strData );
			CTechnologyDesc* pTechDesc = new CTechnologyDesc( this );
			pTechDesc->Deserialize( pSerial );
			m_TechnologyList.AddTail( pTechDesc );
		}
		/*
		strData += ANSI8("<Technology>\n");
		pos = m_TechnologyList.GetHeadPosition();
		while( pos )
		{
			//m_TechnologyList.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</Technology>\n");
		*/

		// Tech Tree nodes - this is stored separately because the same tech can appear
		//   in multiple places in the tech tree - e.g. a basic technology.  This makes it
		//   impossible to put all the child/parent tree information into a CTechnology object.
		// Instead, I have multiple copies of the "Electronics 1" tech.
//		strData += ANSI8("<TechTree>\n");
		/*
		pos = m_TechTreeHeadNodes.GetHeadPosition();
		while( pos )
		{
			//m_TechTreeHeadNodes.GetNext( pos )->AppendDataToXMLString( strData );
		}
		*/
		//iCount = m_TechTreeNodes.GetCount();
		pSerial->Deserialize( iCount );
		//pos = m_TechTreeNodes.GetHeadPosition();
		//while( pos )
		for( long i=0; i<iCount; i++ )
		{
			//CTechTreeNode* pTechTreeNode = m_TechTreeNodes.GetNext( pos );
			//if( pTechTreeNode->m_pParentNode == NULL )
			//{
			//	pTechTreeNode->Serialize( pSerial );
			//}
			CTechTreeNode* pTechTreeNode = new CTechTreeNode( this );
			pTechTreeNode->Deserialize( pSerial );
			//m_TechTreeNodes.AddTail( pTechTreeNode );
		}
		// Read the Tech tree so I know the height of each node
		pos = m_TechTreeNodes.GetHeadPosition();
		while( pos )
		{
			CTechTreeNode* pTreeNode = m_TechTreeNodes.GetNext( pos );
			if( pTreeNode->m_pParentNode == NULL )
			{
				pTreeNode->CalculateHeightOfChildren();
			}
		}

		// Calculate the PrereqTech values
		pos = m_TechnologyList.GetHeadPosition();
		while( pos )
		{
			CTechnologyDesc* pTechDesc = m_TechnologyList.GetNext( pos );
			pTechDesc->CalculatePrereqTechCost2();
		}

		// Make sure all the upgrade information is good
		pos = m_UnitTemplateList.GetHeadPosition();
		while( pos )
		{
			CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
			if( pUnitTemplate )
			{
				CString strUpgrade = pUnitTemplate->GetGenericUpgrade();
				CUnitTemplate* pUpgrade = GetUnitTemplate( strUpgrade );
				if( pUpgrade == NULL || pUnitTemplate == pUpgrade )
				{
					pUnitTemplate->SetGenericUpgrade( _T("") );
				}
				POSITION pos2 = pUnitTemplate->GetUnitsubsetUpgradeList()->GetHeadPosition();
				while( pos2 )
				{
					CUnitsubsetUpgrade* pUnitsubsetUpgrade = pUnitTemplate->GetUnitsubsetUpgradeList()->GetNext( pos2 );
					CUnitTemplate* pUpgrade = GetUnitTemplate( pUnitsubsetUpgrade->m_strUpgrade );
					if( pUpgrade == NULL || pUnitTemplate == pUpgrade )
					{
						pUnitTemplate->RemoveUnitsubsetUpgrade( pUnitsubsetUpgrade->m_strUnitsubset );
					}
				}
			}
		}

		/*
		pos = m_TechTreeNodes.GetHeadPosition();
		while( pos )
		{
			CTechTreeNode* pTechTreeNode = m_TechTreeNodes.GetNext( pos );
			//if( pTechTreeNode->m_ParentNodes.IsEmpty() )
			if( pTechTreeNode->m_pParentNode == NULL )
			{
				//pTechTreeNode->AppendDataToXMLString( strData );
			}
		}
		strData += ANSI8("</TechTree>\n");
		*/
	//
	// Analysis
	//
		//iCount = m_AnalysisList.GetCount();
		pSerial->Deserialize( iCount );
		//pos = m_AnalysisList.GetHeadPosition();
		//while( pos )
		for( long i=0; i<iCount; i++ )
		{
			//CAnalysisUnitTemplateList* pAnalysis = m_AnalysisList.GetNext( pos );
			//pAnalysis->Serialize( pSerial );
			CAnalysisUnitTemplateList* pAnalysis = new CAnalysisUnitTemplateList();
			pAnalysis->Deserialize( pSerial );
			m_AnalysisList.AddTail( pAnalysis );
		}
	/*
		strData += ANSI8("<AnalysisSet>\n");
		pos = m_AnalysisList.GetHeadPosition();
		while( pos )
		{
			CAnalysisUnitTemplateList* pAnalysis = m_AnalysisList.GetNext( pos );
			//pAnalysis->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</AnalysisSet>\n");

	strData += ANSI8("</Body>");
	*/
}

#ifdef DO_NOT_COMPILE_OLD_FUNCTIONS

void CUnitset::WriteUnitsetXMLFile( CString strFullFilename, bool bChangeFileUID )
{
	CStdioFile OutputFile;
	if( OutputFile.Open( strFullFilename, CFile::modeCreate | CFile::modeWrite | CFile::shareDenyNone | CFile::typeText ) )
	{
		CStringANSI8 strXMLString;
		if( bChangeFileUID )
		{
			m_strFileUID = CBCString::GenerateFileUID( m_strTitle + _T(".u.") );
		}
		ASSERT( m_strFileUID != _T("") );
		WriteUnitsetXMLToString( strXMLString );

		OutputFile.Write( strXMLString, strXMLString.GetLength() );
		OutputFile.Close();
	}
}

void  CUnitset::WriteUnitsetXMLToString( CStringANSI8& strXMLStringANSI8 )
{
	CStringANSI8 strHeaderUTF8, strBodyUTF8;
	strXMLStringANSI8 = ANSI8("<Unitset>\n");

	WriteUnitsetHeaderXMLToString( strHeaderUTF8 );
	WriteUnitsetBodyXMLToString( strBodyUTF8 );
	WriteUnitsetChecksumXMLToString( strXMLStringANSI8, strHeaderUTF8, strBodyUTF8 );

	strXMLStringANSI8 += strHeaderUTF8;
	strXMLStringANSI8 += ANSI8("\n");
	strXMLStringANSI8 += strBodyUTF8;

	strXMLStringANSI8 += ANSI8("</Unitset>\n");
}

void  CUnitset::WriteUnitsetChecksumXMLToString( CStringANSI8& strXML, CStringANSI8 strHeaderUTF8, CStringANSI8 strBodyUTF8 )
{
	// Some randomization (to hinder cracking)
	CStringANSI8 strTempUTF8;
	CStringANSI8 strRandomizerStringANSI8;
	LARGE_INTEGER LargeInt = CBCStopwatch2::GetTime_LargeInteger();

	srand( timeGetTime() );
	strRandomizerStringANSI8 += CBCString::GetRandString_NumbersLowercase( 20 );

	strTempUTF8.Format( ANSI8("%02u"), LargeInt.LowPart%100 ); 
	strRandomizerStringANSI8 += strTempUTF8;

	strRandomizerStringANSI8 += CBCString::GetRandString_NumbersLowercase( 10 );

	strTempUTF8.Format( ANSI8("%02u"), ((LargeInt.LowPart/100)+65)%100 );
	strRandomizerStringANSI8 += strTempUTF8;

	strRandomizerStringANSI8 += CBCString::GetRandString_NumbersLowercase( 10 );

	strTempUTF8.Format( ANSI8("%02u"), ((LargeInt.LowPart/100)+16)%100 );
	strRandomizerStringANSI8 += strTempUTF8;

	strRandomizerStringANSI8 += CBCString::GetRandString_NumbersLowercase( 10 );

	strTempUTF8.Format( ANSI8("%02u"), ((LargeInt.LowPart/10000)+11)%100 );
	strRandomizerStringANSI8 += strTempUTF8;

	strRandomizerStringANSI8 += CBCString::GetRandString_NumbersLowercase( 10 );

	strTempUTF8.Format( ANSI8("%02u"), ((LargeInt.LowPart/1000000)+74)%100 );
	strRandomizerStringANSI8 += strTempUTF8;

	srand( timeGetTime()+rand() );
	strRandomizerStringANSI8 += CBCString::GetRandString_NumbersLowercase( 10 );

	CString strNewXML;
	strNewXML = ANSI8("<C>\n");

		strNewXML += ANSI8("<1>") + strRandomizerStringANSI8 + ANSI8("</1>\n");

		CStringANSI8 strHeaderChecksumUTF8 = CBCString::GetChecksum( strRandomizerStringANSI8, strHeaderUTF8 );
		strNewXML += ANSI8("<2>") + strHeaderChecksumUTF8 + ANSI8("</2>\n");

		CStringANSI8 strBodyChecksumUTF8 = CBCString::GetChecksum( strRandomizerStringANSI8, strBodyUTF8 );
		strNewXML += ANSI8("<3>") + strBodyChecksumUTF8 + ANSI8("</3>\n");

		CStringANSI8 strFullChecksumUTF8 = CBCString::GetChecksum( strHeaderChecksumUTF8, strBodyChecksumUTF8 );
		strNewXML += ANSI8("<4>") + strFullChecksumUTF8 + ANSI8("</4>\n");

	strNewXML += ANSI8("</C>\n");

	strXML += strNewXML;
}

void  CUnitset::WriteUnitsetHeaderXMLToString( CStringANSI8& strData )
{
	strData = ANSI8("<Header>\n");

	ASSERT( m_strTitle != _T("") );
	//ASSERT( m_strAuthor != "" );
	ASSERT( m_strVersionAsTimestamp != _T("") );

	strData += ANSI8("<FileUID>") + CStringANSI8( m_strFileUID ) + ANSI8("</FileUID>\n");
	strData += ANSI8("<Title>") + CStringANSI8( m_strTitle ) + ANSI8("</Title>\n");
	strData += ANSI8("<Author>") + CStringANSI8( m_strAuthor ) + ANSI8("</Author>\n");
	strData += ANSI8("<DerivedFromAuthor>") + CStringANSI8( m_strDerivedFromAuthor ) + ANSI8("</DerivedFromAuthor>\n");
	//strData += "<UnitsetUniqueId>" + m_strUnitsetUniqueId + "</UnitsetUniqueId>\n";
	strData += ANSI8("<Version>") + CStringANSI8( m_strVersionAsTimestamp ) + ANSI8("</Version>\n");
	//strData += "<Version>" + g_pApp->GetCurrentTimeSortString() + "</Version>\n";

	strData += ANSI8("<AppVersion>") + CStringANSI8( g_pApp->GetApplicationVersion().GetString() ) + ANSI8("</AppVersion>\n");

	strData += ANSI8("<UnitCount>") + CBCStringANSI8::LongAsString( m_UnitTemplateList.GetCount() ) + ANSI8("</UnitCount>\n");
	strData += ANSI8("<TechCount>") + CBCStringANSI8::LongAsString( m_TechnologyList.GetCount() ) + ANSI8("</TechCount>\n");
	strData += ANSI8("<BuildingCount>") + CBCStringANSI8::LongAsString( m_BuildingDescriptionList.GetCount() ) + ANSI8("</BuildingCount>\n");

	strData += ANSI8("<Description>") + CStringANSI8( m_strDescription ) + ANSI8("</Description>\n");

	//strData += "<Summary>" + m_strWebpageSummary + "</Summary>";
	strData += ANSI8("<UnitSummary>") + CStringANSI8( m_strUnitSummary ) + ANSI8("</UnitSummary>\n");
	strData += ANSI8("<TechSummary>") + CStringANSI8( m_strTechSummary ) + ANSI8("</TechSummary>\n");
	strData += ANSI8("<BuildingSummary>") + CStringANSI8( m_strBuildingSummary ) + ANSI8("</BuildingSummary>\n");
	strData += ANSI8("<TerrainSummary>") + CStringANSI8( m_strTerrainSummary ) + ANSI8("</TerrainSummary>\n");

	strData += ANSI8("<Unitsubsets>\n");
	POSITION pos = m_UnitsubsetList.GetHeadPosition();
	while( pos )
	{
		CString strUnitsubset = m_UnitsubsetList.GetNext( pos );
		strData += ANSI8("<Unitsubset>") + CStringANSI8( strUnitsubset ) + ANSI8("</Unitsubset>\n");
	}
	strData += ANSI8("</Unitsubsets>\n");

	//
	// Create a checksum
	//
	/*
	CString strData1 = "dea9kawd09kDSWq32dcwmSW089m3wqe908DdasDWW340fda9skadspo";
	long iData1Size = strData1.GetLength();
	//
	long iRawChecksumSize = 40;
	byte RawChecksum[40];
	for( long i=0; i<iRawChecksumSize; i++ ){ RawChecksum[i] = 0; }

	long  iSize = strBody.GetLength();
	for( long i=0; i<iSize; i++ )
	{
		char cBody = strBody[i];
		char cData1 = strData1[ i%iData1Size ];
		cBody ^= cData1;
		RawChecksum[ cBody%iRawChecksumSize ] ^= cBody;

		/-*
		RawChecksum

		long iData1 = strData1.GetLength();
		char cData1 = strData1.GetAt( iSize%iData1 );

		if( (cData1 & 0x01) && (pData[i] & 0x01) ) iChecksum1++;
		if( (cData1 & 0x02) && (pData[i] & 0x02) ) iChecksum1++;
		if( (cData1 & 0x04) && (pData[i] & 0x04) ) iChecksum1++;
		if( (cData1 & 0x08) && (pData[i] & 0x08) ) iChecksum1++;
		if( (cData1 & 0x10) && (pData[i] & 0x10) ) iChecksum1++;
		if( (cData1 & 0x20) && (pData[i] & 0x20) ) iChecksum1++;
		if( (cData1 & 0x40) && (pData[i] & 0x40) ) iChecksum1++;
		if( (cData1 & 0x80) && (pData[i] & 0x80) ) iChecksum1++;
		*-/
		//
	}
	// Convert the 40-char RawChecksum into hex
	CString strChecksum;
	for( long i=0; i<iRawChecksumSize; i++ )
	{
		long iVal1 = 0;
		if( RawChecksum[i] & 0x01 ) iVal1 += 1;
		if( RawChecksum[i] & 0x02 ) iVal1 += 2;
		if( RawChecksum[i] & 0x04 ) iVal1 += 4;
		if( RawChecksum[i] & 0x08 ) iVal1 += 8;
		strChecksum += "0" + iVal1;

		long iVal2 = 0;
		if( RawChecksum[i] & 0x10 ) iVal2 += 1;
		if( RawChecksum[i] & 0x20 ) iVal2 += 2;
		if( RawChecksum[i] & 0x40 ) iVal2 += 4;
		if( RawChecksum[i] & 0x80 ) iVal2 += 8;
		strChecksum += "0" + iVal2;
	}
	*/

/*
	CBCStopwatch2 watch;
	watch.Start();
	CString strChecksum = CBCString::GetChecksum( strBody );
	watch.Stop();
	float fTime = watch.GetDeltaSeconds();

	//strData += "<c></c>\n";
	strData += "<c>" + strChecksum + "</c>\n";
*/
	strData += ANSI8("</Header>");
}

void  CUnitset::WriteUnitsetBodyXMLToString( CStringANSI8& strData )
{
	POSITION pos;
	strData = ANSI8("<Body>\n");

	//
	// Unitsubsets and the bonuses associated with each (move code from below)
	//
	strData += ANSI8("<UnitSubsets>\n");

	long iPasses = m_UnitsubsetList.GetCount() + 1;
	for( long iPass=0; iPass<iPasses; iPass++ )
	{
		CString strUnitsubset = _T("");
		if( iPass == 0 )
		{
			strData += ANSI8("<AllSubsets>");
		}
		else
		{
			strUnitsubset = m_UnitsubsetList.GetAt( m_UnitsubsetList.FindIndex( iPass-1 ) );
			strData += ANSI8("<Subset>\n");
			strData += ANSI8("<Name>") + CStringANSI8( strUnitsubset ) + ANSI8("</Name>\n");
		}

		strData += ANSI8("<Free>\n");
		pos = m_InitialFreeTechnologyList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeTechnologyList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Tech>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Tech>\n");
			}
		}
		pos = m_InitialFreeUnitCoastalCityList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitCoastalCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Unit-Coastal>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Unit-Coastal>\n");
			}
		}
		pos = m_InitialFreeUnitLandlockedCityList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitLandlockedCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Unit-Landlocked>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Unit-Landlocked>\n");
			}
		}
		strData += ANSI8("</Free>\n");

		strData += ANSI8("<InitialCanBuild>");
		pos = m_InitialCanBuildUnitList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Unit>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Unit>\n");
			}
		}
		pos = m_InitialCanBuildBuildingList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += ANSI8("<Building>") + CStringANSI8( pUnitsubsetValue->m_strValue ) + ANSI8("</Building>\n");
			}
		}
		strData += ANSI8("</InitialCanBuild>");
		/*
		pos = m_AllowResearchList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_AllowResearchList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				strData += "<ResearchAllowed>" + pUnitsubsetValue->m_strValue + "</ResearchAllowed>\n";
			}
		}
		*/

		if( iPass == 0 ){ strData += ANSI8("</AllSubsets>\n"); }
		else{ strData += ANSI8("</Subset>\n"); }
	}
	strData += ANSI8("</UnitSubsets>\n");

	// Write "AllowTechnology" information
	/*
	strData += "<AllowTechnology>\n";
	pos = m_Allow_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CItemAndUnitsubset* pItemAndUnitsubset = m_Allow_TechnologyList.GetNext( pos );
		pItemAndUnitsubset->AppendDataToXMLString( strData );
	}
	strData += "</AllowTechnology>\n";
	*/
	// Write "AllowUnit" information
	/*A
	strData += "<AllowUnit>\n";
	pos = m_Allow_UnitList.GetHeadPosition();
	while( pos )
	{
		CItemAndUnitsubset* pItemAndUnitsubset = m_Allow_UnitList.GetNext( pos );
		pItemAndUnitsubset->AppendDataToXMLString( strData );
	}
	strData += "</AllowUnit>\n";
	*/

	// Write "AllowBuilding" information
	/*
	strData += "<AllowBuilding>\n";
	pos = m_Allow_BuildingList.GetHeadPosition();
	while( pos )
	{
		CItemAndUnitsubset* pItemAndUnitsubset = m_Allow_BuildingList.GetNext( pos );
		pItemAndUnitsubset->AppendDataToXMLString( strData );
	}
	strData += "</AllowBuilding>\n";
	*/

	//
	// Animations used by this unitset
	//
		// Should I derive this information from the UnitTemplate information?
		

	//
	// Basic Combat/Movement Information
	//
		// Combat Unit Types
		strData += ANSI8("<CombatUnitTypes>\n");
		pos = m_CombatUnitTypes.GetHeadPosition();
		while( pos )
		{
			m_CombatUnitTypes.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</CombatUnitTypes>\n");

		// Movement Unit Types
		strData += ANSI8("<MovementUnitTypes>\n");
		pos = m_MovementUnitTypes.GetHeadPosition();
		while( pos )
		{
			m_MovementUnitTypes.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</MovementUnitTypes>\n");

	//
	// Categories
	//
		strData += ANSI8("<UnitCategories>\n");
		pos = m_UnitCategories.GetHeadPosition();
		while( pos )
		{
			m_UnitCategories.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</UnitCategories>\n");

	//
	// City/Resource/Airfield View Ranges
	//
		// City Description
		strData += ANSI8("<CityDescription>\n");
		//strData += "<DefaultViewRange>" + CBCString::FloatAsString(CCity::GetDefaultViewRange2()) + "</DefaultViewRange>\n";
		strData += ANSI8("<DefaultViewRange>") + CBCStringANSI8::FloatAsString(m_fCityDefaultViewRange) + ANSI8("</DefaultViewRange>\n");
		//pos = CCity::GetViewRangeList()->GetHeadPosition();
		pos = GetCityViewRangeList()->GetHeadPosition();
		while( pos )
		{
			CViewRange* pViewRange = GetCityViewRangeList()->GetNext( pos );
			strData += ANSI8("<SpecialViewRange>\n");
			strData += ANSI8("<UnitTag>") + CStringANSI8( pViewRange->m_strUnitTag ) + ANSI8("</UnitTag>");
			strData += ANSI8("<Range>") + CBCStringANSI8::FloatAsString(pViewRange->m_fViewRange) + ANSI8("</Range>");
			strData += ANSI8("</SpecialViewRange>\n");
		}
		strData += ANSI8("<OilConsumption>") + CBCStringANSI8::FloatAsString(m_fCityOilConsumption) + ANSI8("</OilConsumption>\n");
		strData += ANSI8("<FoodConsumption>") + CBCStringANSI8::FloatAsString(m_fCityFoodConsumption) + ANSI8("</FoodConsumption>\n");
		strData += ANSI8("</CityDescription>\n");

		// Resource Description
		strData += ANSI8("<ResourceDescription>\n");
		strData += ANSI8("<DefaultViewRange>") + CBCStringANSI8::FloatAsString(m_fResourceDefaultViewRange) + ANSI8("</DefaultViewRange>\n");
		pos = GetResourceViewRangeList()->GetHeadPosition();
		while( pos )
		{
			CViewRange* pViewRange = GetResourceViewRangeList()->GetNext( pos );
			strData += ANSI8("<SpecialViewRange>\n");
			strData += ANSI8("<UnitTag>") + CStringANSI8( pViewRange->m_strUnitTag ) + ANSI8("</UnitTag>");
			strData += ANSI8("<Range>") + CBCStringANSI8::FloatAsString(pViewRange->m_fViewRange) + ANSI8("</Range>");
			strData += ANSI8("</SpecialViewRange>\n");
		}
		strData += ANSI8("</ResourceDescription>\n");

		// Airfield Description
		strData += ANSI8("<AirfieldDescription>\n");
		strData += ANSI8("<Cost>") + CBCStringANSI8::FloatAsString(m_fAirfieldConstructionCost) + ANSI8("</Cost>\n");
		strData += ANSI8("<DefaultViewRange>") + CBCStringANSI8::FloatAsString(m_fAirfieldDefaultViewRange) + ANSI8("</DefaultViewRange>\n");
		//pos = CAirfield::GetViewRangeList()->GetHeadPosition();
		pos = GetAirfieldViewRangeList()->GetHeadPosition();
		while( pos )
		{
			CViewRange* pViewRange = GetAirfieldViewRangeList()->GetNext( pos );
			strData += ANSI8("<SpecialViewRange>\n");
			strData += ANSI8("<UnitTag>") + CStringANSI8( pViewRange->m_strUnitTag ) + ANSI8("</UnitTag>");
			strData += ANSI8("<Range>") + CBCStringANSI8::FloatAsString(pViewRange->m_fViewRange) + ANSI8("</Range>");
			strData += ANSI8("</SpecialViewRange>\n");
		}
		strData += ANSI8("</AirfieldDescription>\n");

		// UnitDefault View Range
		strData += ANSI8("<UnitDefaults>\n");
		pos = m_UnitDefaultViewRangeList.GetHeadPosition();
		while( pos )
		{
			CViewRange* pViewRange = m_UnitDefaultViewRangeList.GetNext( pos );
			strData += ANSI8("<SpecialViewRange>\n");
			strData += ANSI8("<UnitTag>") + CStringANSI8( pViewRange->m_strUnitTag ) + ANSI8("</UnitTag>");
			strData += ANSI8("<Range>") + CBCStringANSI8::FloatAsString(pViewRange->m_fViewRange) + ANSI8("</Range>");
			strData += ANSI8("</SpecialViewRange>\n");
		}
		strData += ANSI8("</UnitDefaults>\n");

	//
	// Unit Templates
	//
		strData += ANSI8("<Units>\n");
		pos = m_UnitTemplateList.GetHeadPosition();
		while( pos )
		{
			m_UnitTemplateList.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</Units>\n");

	//
	// Buildings
	//
		strData += ANSI8("<Buildings>\n");
		pos = m_BuildingDescriptionList.GetHeadPosition();
		while( pos )
		{
			m_BuildingDescriptionList.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</Buildings>\n");

	//
	// Militia units
	//
		strData += ANSI8("<Militia>\n");
		pos = m_InitialMilitiaUnitList.GetHeadPosition();
		while( pos )
		{
			CString strMilitia = m_InitialMilitiaUnitList.GetNext( pos );
			strData += ANSI8("<Unit>") + CStringANSI8( strMilitia ) + ANSI8("</Unit>\n");
		}
		strData += ANSI8("</Militia>\n");

	//
	// Technology
	//
		strData += ANSI8("<Technology>\n");
		pos = m_TechnologyList.GetHeadPosition();
		while( pos )
		{
			m_TechnologyList.GetNext( pos )->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</Technology>\n");

		// Tech Tree nodes - this is stored separately because the same tech can appear
		//   in multiple places in the tech tree - e.g. a basic technology.  This makes it
		//   impossible to put all the child/parent tree information into a CTechnology object.
		// Instead, I have multiple copies of the "Electronics 1" tech.
		strData += ANSI8("<TechTree>\n");
		/*
		pos = m_TechTreeHeadNodes.GetHeadPosition();
		while( pos )
		{
			m_TechTreeHeadNodes.GetNext( pos )->AppendDataToXMLString( strData );
		}
		*/
		pos = m_TechTreeNodes.GetHeadPosition();
		while( pos )
		{
			CTechTreeNode* pTechTreeNode = m_TechTreeNodes.GetNext( pos );
			//if( pTechTreeNode->m_ParentNodes.IsEmpty() )
			if( pTechTreeNode->m_pParentNode == NULL )
			{
				pTechTreeNode->AppendDataToXMLString( strData );
			}
		}
		strData += ANSI8("</TechTree>\n");
	//
	// Analysis
	//
		strData += ANSI8("<AnalysisSet>\n");
		pos = m_AnalysisList.GetHeadPosition();
		while( pos )
		{
			CAnalysisUnitTemplateList* pAnalysis = m_AnalysisList.GetNext( pos );
			pAnalysis->AppendDataToXMLString( strData );
		}
		strData += ANSI8("</AnalysisSet>\n");

	strData += ANSI8("</Body>");
}
#endif DO_NOT_COMPILE_OLD_FUNCTIONS

bool  CUnitset::LoadUnitsetFileDataAndValidateChecksum( CString strFullFilename, CStringANSI8& strFileData )
{
	// Read the file (for checksum calculations)
	strFileData = CBCString::ReadANSI8FileAsANSI8( strFullFilename );

	long iChecksumStart = strFileData.Find( ANSI8("<C>") );
	long iChecksumEnd = strFileData.Find( ANSI8("</C>") );
	CStringANSI8 strInternalRandomizerString;
	CStringANSI8 strInternalChecksum2;
	CStringANSI8 strInternalChecksum3;
	CStringANSI8 strInternalChecksum4;
	if( iChecksumStart > -1 && iChecksumEnd > -1 )
	{
		long iChecksumEnd2 = iChecksumEnd + (long)strlen( ANSI8("</C>") );
		CStringANSI8 strChecksumBlock = strFileData.Mid( iChecksumStart, iChecksumEnd2-iChecksumStart );

		strInternalRandomizerString = CBCStringANSI8::GetEverythingBetween( strChecksumBlock, ANSI8("<1>"),ANSI8("</1>") );
		strInternalChecksum2        = CBCStringANSI8::GetEverythingBetween( strChecksumBlock, ANSI8("<2>"),ANSI8("</2>") );
		strInternalChecksum3        = CBCStringANSI8::GetEverythingBetween( strChecksumBlock, ANSI8("<3>"),ANSI8("</3>") );
		strInternalChecksum4        = CBCStringANSI8::GetEverythingBetween( strChecksumBlock, ANSI8("<4>"),ANSI8("</4>") );
	}

	long iHeaderStart = strFileData.Find( ANSI8("<Header>") );
	long iHeaderEnd = strFileData.Find( ANSI8("</Header>") );
	CStringANSI8 strCalculatedHeaderChecksum;
	if( iHeaderStart > -1 && iHeaderEnd > -1 )
	{
		long iHeaderEnd2 = iHeaderEnd + (long)strlen( ANSI8("</Header>") );
		CStringANSI8 strHeader = strFileData.Mid( iHeaderStart, iHeaderEnd2-iHeaderStart );
		strCalculatedHeaderChecksum = CBCString::GetChecksum( strInternalRandomizerString, strHeader );
	}

	long iBodyStart = strFileData.Find( ANSI8("<Body>") );
	long iBodyEnd = strFileData.Find( ANSI8("</Body>") );
	CStringANSI8 strCalculatedBodyChecksum;
	if( iBodyStart > -1 && iBodyEnd > -1 )
	{
		long iBodyEnd2 = iBodyEnd + (long)strlen( ANSI8("</Body>") );
		CStringANSI8 strBody = strFileData.Mid( iBodyStart, iBodyEnd2-iBodyStart );
		strCalculatedBodyChecksum = CBCString::GetChecksum( strInternalRandomizerString, strBody );
	}

	CStringANSI8 strCalculatedFullChecksum;
	strCalculatedFullChecksum = CBCString::GetChecksum( strCalculatedHeaderChecksum, strCalculatedBodyChecksum );

	m_bGoodChecksum = true;
	if( strInternalChecksum2 != strCalculatedHeaderChecksum ||
		strInternalChecksum3 != strCalculatedBodyChecksum ||
		strInternalChecksum4 != strCalculatedFullChecksum )
	{
		m_bGoodChecksum = false;
		if( Public::m_bFailOnBadChecksum ) // Bad Unitset File
		{
			Checkpoint::Write( _T("CUnitset::LoadUnitsetFileDataAndValidateChecksum - bad checkpoint") );
			// Bad checksum
			//m_bBadChecksum = true;
			//#ifdef _DEBUG
			//ASSERT( false );
			//#else
			//strFileData = "";
			//return false; // fail loading the file
			//#endif
			strFileData = _T("");
			return false; // fail loading the file
		}
	}
	return true;
}

bool  CUnitset::ReadUnitsetXMLFile( CString strFullFilename )
{
	CString strExternalTitle;
	CString strExternalVersion;
	CString strExternalAuthor;
	CBCFile::DissectFile( CBCString::GetFilename( strFullFilename ), &strExternalTitle, &strExternalAuthor, &strExternalVersion, NULL );

	long iCurrentUnitTemplateIndex = 0;

	CStringANSI8 strUnitsetData;
	if( LoadUnitsetFileDataAndValidateChecksum( strFullFilename, strUnitsetData ) == false ) return false;
/*
	// Read the file (for checksum calculations)
	CString strUnitsetData = CBCString::ReadFile( strFullFilename );

	long iChecksumStart = strUnitsetData.Find( "<C>" );
	long iChecksumEnd = strUnitsetData.Find( "</C>" );
	CString strInternalRandomizerString;
	CString strInternalChecksum2;
	CString strInternalChecksum3;
	CString strInternalChecksum4;
	if( iChecksumStart > -1 && iChecksumEnd > -1 )
	{
		long iChecksumEnd2 = iChecksumEnd + strlen( "</C>" );
		CString strChecksumBlock = strUnitsetData.Mid( iChecksumStart, iChecksumEnd2-iChecksumStart );

		strInternalRandomizerString = CBCString::GetEverythingBetween( strChecksumBlock, "<1>","</1>" );
		strInternalChecksum2        = CBCString::GetEverythingBetween( strChecksumBlock, "<2>","</2>" );
		strInternalChecksum3        = CBCString::GetEverythingBetween( strChecksumBlock, "<3>","</3>" );
		strInternalChecksum4        = CBCString::GetEverythingBetween( strChecksumBlock, "<4>","</4>" );
	}

	long iHeaderStart = strUnitsetData.Find( "<Header>" );
	long iHeaderEnd = strUnitsetData.Find( "</Header>" );
	CString strCalculatedHeaderChecksum;
	if( iHeaderStart > -1 && iHeaderEnd > -1 )
	{
		long iHeaderEnd2 = iHeaderEnd + strlen( "</Header>" );
		CString strHeader = strUnitsetData.Mid( iHeaderStart, iHeaderEnd2-iHeaderStart );
		strCalculatedHeaderChecksum = CBCString::GetChecksum( strInternalRandomizerString, strHeader );
	}

	long iBodyStart = strUnitsetData.Find( "<Body>" );
	long iBodyEnd = strUnitsetData.Find( "</Body>" );
	CString strCalculatedBodyChecksum;
	if( iBodyStart > -1 && iBodyEnd > -1 )
	{
		long iBodyEnd2 = iBodyEnd + strlen( "</Body>" );
		CString strBody = strUnitsetData.Mid( iBodyStart, iBodyEnd2-iBodyStart );
		strCalculatedBodyChecksum = CBCString::GetChecksum( strInternalRandomizerString, strBody );
	}

	CString strCalculatedFullChecksum;
	strCalculatedFullChecksum = CBCString::GetChecksum( strCalculatedHeaderChecksum, strCalculatedBodyChecksum );

	if( strInternalChecksum2 != strCalculatedHeaderChecksum ||
		strInternalChecksum3 != strCalculatedBodyChecksum ||
		strInternalChecksum4 != strCalculatedFullChecksum )
	{
		// Bad checksum
		#ifdef _DEBUG
		//ASSERT( false );
		#else
		return false; // fail loading the file
		#endif
		int g=0;
	}
*/
	CBCXMLReader  XMLReader;
	//XMLReader.ReadFile( strFullFilename );
	XMLReader.Set( strUnitsetData );
	CBCXMLItem* pBase = XMLReader.GetItem( ANSI8("Unitset") );
	if( pBase )
	{
		m_strLocalFile = CBCString::GetFilename( strFullFilename );
		m_strLocalPath = strFullFilename;

		CBCXMLItem* pHeader = pBase->GetItem( ANSI8("Header") );
		if( pHeader )
		{
			/*
			CString strChecksumInHeader = pHeader->GetValue( "c" );
			if( strCalculatedChecksum != strChecksumInHeader )
			{
				// Bad checksum

				#ifdef _DEBUG
				ASSERT( false );
				#else
				return false; // fail loading the file
				#endif
			}
			*/

			this->m_strTitle = pHeader->GetValue( ANSI8("Title") );
			this->m_strAuthor = pHeader->GetValue( ANSI8("Author") );
			//this->m_strUnitsetUniqueId = pHeader->GetValue( "UnitsetUniqueId" );
			this->m_strFileUID = pHeader->GetValue( ANSI8("FileUID") );

			this->m_strVersionAsTimestamp = pHeader->GetValue( ANSI8("Version") );
			this->m_strApplicationVersion = pHeader->GetValue( ANSI8("AppVersion") );

			//if( strExternalTitle != "" && strExternalTitle != m_strTitle ){ ASSERT( false ); return; }
			//if( strExternalVersion != "" && strExternalVersion != m_strVersionAsTimestamp ){ ASSERT( false ); return; }
			//if( strExternalAuthor != "" && strExternalAuthor != m_strAuthor ){ ASSERT( false ); return; }
			if( strExternalTitle != m_strTitle ){ ASSERT( false ); return false; }
			if( strExternalVersion != m_strVersionAsTimestamp ){ ASSERT( false ); return false; }
			if( strExternalAuthor != _T("(local)") && strExternalAuthor != m_strAuthor ){ ASSERT( false ); return false; }
			//if( strExternalAuthor != "" && strExternalAuthor != m_strAuthor ){ ASSERT( false ); return; }

			//this->m_strFileId = pHeader->GetValue( "FileId" );
			//this->m_strFileThread = pHeader->GetValue( "FileThread" );
			//this->m_strAuthor = pHeader->GetValue( "Author" );
			this->m_strDescription = pHeader->GetValue( ANSI8("Description") );

			//this->m_strWebpageSummary = pHeader->GetValue( "Summary" );
			this->m_strUnitSummary = pHeader->GetValue( ANSI8("UnitSummary") );
			this->m_strTechSummary = pHeader->GetValue( ANSI8("TechSummary") );
			this->m_strBuildingSummary = pHeader->GetValue( ANSI8("BuildingSummary") );
			this->m_strTerrainSummary = pHeader->GetValue( ANSI8("TerrainSummary") );

			CBCXMLItem* pUnitsubset = pHeader->GetItem( ANSI8("Unitsubsets") );
			if( pUnitsubset )
			{
				long iCount = pUnitsubset->GetCount( ANSI8("Unitsubset") );
				for( long i=0; i<iCount; i++ )
				{
					CString strSubset; strSubset = pUnitsubset->GetValue( ANSI8("Unitsubset"), i );
					m_UnitsubsetList.AddTail( strSubset );
				}
			}
		}

		// Setup initial resources
		POSITION pos = m_UnitsubsetList.GetHeadPosition();
		while( pos )
		{
			CString strUnitsubset = m_UnitsubsetList.GetNext( pos );
			m_InitialResources.AddTail( new CUnitsubsetStringLongValue( strUnitsubset, _T("Money"), 100 ) );
			m_InitialResources.AddTail( new CUnitsubsetStringLongValue( strUnitsubset, _T("Iron"), 100 ) );
			m_InitialResources.AddTail( new CUnitsubsetStringLongValue( strUnitsubset, _T("Oil"), 100 ) );
			m_InitialResources.AddTail( new CUnitsubsetStringLongValue( strUnitsubset, _T("Food"), 100 ) );
		}

		CBCXMLItem* pBody = pBase->GetItem( ANSI8("Body") );
		if( pBody )
		{
			// Setup the random table
			//
			SetCombatRandomness01( 0.5f ); // The default value is 0.5
			//CCombatManager::SetupRandomTable( 1.0f );

			//
			// UnitSubsets
			//
				CBCXMLItem* pUnitSubsets = pBody->GetItem( ANSI8("UnitSubsets") );
				if( pUnitSubsets )
				{
					long iSubsetCount = pUnitSubsets->GetCount( ANSI8("Subset") );
					iSubsetCount++;

					for( long iPass=0; iPass<iSubsetCount; iPass++ )
					{
						CString strUnitsubset;
						CBCXMLItem* pSubset;
						if( iPass == 0 ){ pSubset = pUnitSubsets->GetItem( ANSI8("AllSubsets") ); }
						else{ pSubset = pUnitSubsets->GetItem( ANSI8("Subset"), iPass-1 ); }

						if( pSubset )
						{
							strUnitsubset = pSubset->GetValue( ANSI8("Name") );

							CBCXMLItem* pFreeItems = pSubset->GetItem( ANSI8("Free") );
							if( pFreeItems )
							{
								POSITION pos = pFreeItems->m_Items.GetHeadPosition();
								while( pos )
								{
									CBCXMLItem* pItem = pFreeItems->m_Items.GetNext( pos );

									if( pItem->m_strKey == ANSI8("Tech") )
									{
										CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, CString( pItem->m_strValue ) );
										m_InitialFreeTechnologyList.AddTail( pVal );
									}
									else if( pItem->m_strKey == ANSI8("Unit") )
									{
										CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, CString( pItem->m_strValue ) );
										m_InitialFreeUnitCoastalCityList.AddTail( pVal );
									}
									else if( pItem->m_strKey == ANSI8("Unit-Coastal") )
									{
										CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, CString( pItem->m_strValue ) );
										m_InitialFreeUnitCoastalCityList.AddTail( pVal );
									}
									else if( pItem->m_strKey == ANSI8("Unit-Landlocked") )
									{
										CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, CString( pItem->m_strValue ) );
										m_InitialFreeUnitLandlockedCityList.AddTail( pVal );
									}
								}
							}

							CBCXMLItem* pInitialCanBuildItems = pSubset->GetItem( ANSI8("InitialCanBuild") );
							if( pInitialCanBuildItems )
							{
								POSITION pos = pInitialCanBuildItems->m_Items.GetHeadPosition();
								while( pos )
								{
									CBCXMLItem* pItem = pInitialCanBuildItems->m_Items.GetNext( pos );

									if( pItem->m_strKey == ANSI8("Unit") )
									{
										CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, CString( pItem->m_strValue ) );
										m_InitialCanBuildUnitList.AddTail( pVal );
									}
									else if( pItem->m_strKey == ANSI8("Building") )
									{
										CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, CString( pItem->m_strValue ) );
										m_InitialCanBuildBuildingList.AddTail( pVal );
									}
								}
							}

							/*
							POSITION pos = pSubset->m_Items.GetHeadPosition();
							while( pos )
							{
								CBCXMLItem* pItem = pSubset->m_Items.GetNext( pos );

								//
								// Will be depreciated
								//

								if( pItem->m_strKey == "FreeTech" )
								{
									CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, pItem->m_strValue );
									m_InitialFreeTechnologyList.AddTail( pVal );
								}
								else if( pItem->m_strKey == "FreeUnit" )
								{
									CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, pItem->m_strValue );
									m_InitialFreeUnitList.AddTail( pVal );
								}
								else if( pItem->m_strKey == "InitialCanBuildUnit" )
								{
									CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, pItem->m_strValue );
									m_InitialCanBuildUnitList.AddTail( pVal );
								}
								else if( pItem->m_strKey == "InitialCanBuildBuilding" )
								{
									CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, pItem->m_strValue );
									m_InitialCanBuildBuildingList.AddTail( pVal );
								}
								else if( pItem->m_strKey == "ResearchAllowed" )
								{
									//
									// Will be depreciated
									//

									CString strTech = pItem->m_strValue;
									CUnitsubsetValue* pVal = new CUnitsubsetValue( strUnitsubset, strTech );
									m_AllowResearchList.AddTail( pVal );

									// Testing
									/-*
									CItemAndUnitsubset* pTest = InvokeAllowTechnologyObj( this, "Flight" );
									pTest->m_bListContainsPositiveItems = false;
									pTest->SetUnitsubsetToPositive( "German" );
									bool b;
									b = pTest->UnitsubsetIsPositive( "German" );
									pTest->SetUnitsubsetToNegative( "German" );
									pTest->SetUnitsubsetToNegative( "American" );
									pTest->m_bListContainsPositiveItems = false;
									b = pTest->UnitsubsetIsPositive( "German" );
									int z=0;
									pTest->SetUnitsubsetToPositive( "German" );
									*-/

									// Create items in the m_Allow_TechnologyList list
									CItemAndUnitsubset* pItemPlus = InvokeAllowTechnologyObj( this, strTech );
									pItemPlus->m_bListContainsPositiveItems = true;
									//pItemPlus->SetUnitsubsetToPositive( strUnitsubset );
									//AddAllowTechnology( strUnitsubset, pItem->m_strValue );
									pItemPlus->SetUnitsubsetToPositive( strUnitsubset );
									m_Allow_TechnologyList.AddTail( pItemPlus );
								}
							}
							*/
						}
					}
				}
			//
			// Allow Technology Information
			//
				/*
				CBCXMLItem* pAllowTechnology = pBody->GetItem( "AllowTechnology" );
				if( pAllowTechnology )
				{
					long iCount = pAllowTechnology->GetCount( "Item" );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pAllowTechnology->GetItem( "Item", i );
						CItemAndUnitsubset* pItemPlus = new CItemAndUnitsubset( this );
						pItemPlus->ReadXMLData( pItem );
						m_Allow_TechnologyList.AddTail( pItemPlus );
					}
				}
				CBCXMLItem* pAllowUnit = pBody->GetItem( "AllowUnit" );
				if( pAllowUnit )
				{
					long iCount = pAllowUnit->GetCount( "Item" );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pAllowUnit->GetItem( "Item", i );
						CItemAndUnitsubset* pItemPlus = new CItemAndUnitsubset( this );
						pItemPlus->ReadXMLData( pItem );
						m_Allow_UnitList.AddTail( pItemPlus );
					}
				}
				CBCXMLItem* pAllowBuilding = pBody->GetItem( "AllowBuilding" );
				if( pAllowBuilding )
				{
					long iCount = pAllowBuilding->GetCount( "Item" );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pAllowBuilding->GetItem( "Item", i );
						CItemAndUnitsubset* pItemPlus = new CItemAndUnitsubset( this );
						pItemPlus->ReadXMLData( pItem );
						m_Allow_BuildingList.AddTail( pItemPlus );
					}
				}
				*/

			//
			// Basic Combat/Movement Information
			//
				// Combat Unit Types
				CBCXMLItem* pCombatUnitTypes = pBody->GetItem( ANSI8("CombatUnitTypes") );
				if( pCombatUnitTypes )
				{
					long iCount = pCombatUnitTypes->GetCount( ANSI8("CombatUnitType") );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pCombatUnitTypes->GetItem( ANSI8("CombatUnitType"), i );
						CCombatUnitType* pCombatUnitType = new CCombatUnitType();
						pCombatUnitType->ReadXMLData( pItem );
						AddCombatUnitType( pCombatUnitType );
						//m_CombatUnitTypes.AddTail( pCombatUnitType );
					}
				}
				// If loading an old version, then we have to switch the docked/prone data
				{
					POSITION pos = m_CombatUnitTypes.GetHeadPosition();
					while( pos )
					{
						CCombatUnitType* pCombatUnitType = m_CombatUnitTypes.GetNext( pos );
						if( pCombatUnitType->m_strLandedOrDockedCombatType_Old != _T("") )
						{
							CCombatUnitType* pOtherCombatUnitType = GetCombatUnitTypeByExternalName( pCombatUnitType->m_strLandedOrDockedCombatType_Old );
							if( pOtherCombatUnitType )
							{
								pCombatUnitType->m_iLandedOrDockedCombatType = pOtherCombatUnitType->m_iCombatUnitType;//GetCombatUnitTypeByExternalName( m_strLandedOrDockedCombatType_Old );
							}				
						}
					}
				}

				// Movement Unit Types
				CBCXMLItem* pMovementUnitTypes = pBody->GetItem( ANSI8("MovementUnitTypes") );
				if( pMovementUnitTypes )
				{
					long iCount = pMovementUnitTypes->GetCount( ANSI8("MovementUnitType") );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pMovementUnitTypes->GetItem( ANSI8("MovementUnitType"), i );
						CMovementUnitType* pMovementUnitType = new CMovementUnitType();
						pMovementUnitType->ReadXMLData( pItem );
						AddMovementUnitType( pMovementUnitType ); // This will assign a MovementUnitType number
						//m_MovementUnitTypes.AddTail( pMovementUnitType );
					}
				}
			//
			// Unit Categories
			//
				CBCXMLItem* pUnitCategories = pBody->GetItem( ANSI8("UnitCategories") );
				if( pUnitCategories )
				{
					long iCount = pUnitCategories->GetCount( ANSI8("Cat") );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pUnitCategories->GetItem( ANSI8("Cat"), i );
						CUnitCategory* pUnitCategory = new CUnitCategory();
						pUnitCategory->ReadXMLData( pItem );
						m_UnitCategories.AddTail( pUnitCategory );
					}
				}

			//
			// City/Resource/Airfield View Ranges
			//
				CBCXMLItem* pCityDescription = pBody->GetItem( ANSI8("CityDescription") );
				if( pCityDescription )
				{
					m_fCityDefaultViewRange = atof( pCityDescription->GetValue(ANSI8("DefaultViewRange")) );
					//CCity::SetDefaultViewRange( _tstof( pCityDescription->GetValue("DefaultViewRange") ) );
					long iCount = pCityDescription->GetCount( ANSI8("SpecialViewRange") );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pCityDescription->GetItem( ANSI8("SpecialViewRange"), i );
						if( pItem )
						{
							//CCity::InvokeViewRange( pItem->GetValue("UnitTag"), _tstof(pItem->GetValue("Range")) );
							InvokeCityViewRange( CString( pItem->GetValue(ANSI8("UnitTag"))), atof(pItem->GetValue(ANSI8("Range"))) );
						}
					}
					m_fCityOilConsumption = atof( pCityDescription->GetValue(ANSI8("OilConsumption")) );
					m_fCityFoodConsumption = atof( pCityDescription->GetValue(ANSI8("FoodConsumption")) );
					int z=0;
				}
				CBCXMLItem* pResourceDescription = pBody->GetItem( ANSI8("ResourceDescription") );
				if( pResourceDescription )
				{
					m_fResourceDefaultViewRange = atof( pResourceDescription->GetValue(ANSI8("DefaultViewRange")) );
					//CResourceSource::SetDefaultViewRange( _tstof( pResourceDescription->GetValue("DefaultViewRange") ) );
					long iCount = pResourceDescription->GetCount( ANSI8("SpecialViewRange") );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pResourceDescription->GetItem( ANSI8("SpecialViewRange"), i );
						if( pItem )
						{
							//CResourceSource::InvokeViewRange( pItem->GetValue("UnitTag"), _tstof(pItem->GetValue("Range")) );
							InvokeResourceViewRange( CString( pItem->GetValue(ANSI8("UnitTag"))), atof(pItem->GetValue(ANSI8("Range"))) );
						}
					}
				}
				CBCXMLItem* pAirfieldDescription = pBody->GetItem( ANSI8("AirfieldDescription") );
				if( pAirfieldDescription )
				{
					//m_fAirfieldConstructionCost = atof( pAirfieldDescription->GetValue(ANSI8("Cost")) );
					float fAirfieldConstructionCost = atof( pAirfieldDescription->GetValue(ANSI8("Cost")) );
					InvokeAirfieldConstructionCost( _T("Money"), fAirfieldConstructionCost );

					m_fAirfieldDefaultViewRange = atof( pAirfieldDescription->GetValue(ANSI8("DefaultViewRange")) );
					//CAirfield::SetDefaultViewRange( _tstof( pAirfieldDescription->GetValue("DefaultViewRange") ) );
					long iCount = pAirfieldDescription->GetCount( ANSI8("SpecialViewRange") );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pAirfieldDescription->GetItem( ANSI8("SpecialViewRange"), i );
						if( pItem )
						{
							InvokeAirfieldViewRange( CString( pItem->GetValue(ANSI8("UnitTag"))), atof(pItem->GetValue(ANSI8("Range"))) );
						}
					}
				}
				CBCXMLItem* pUnitDefaults = pBody->GetItem( ANSI8("UnitDefaults") );
				if( pUnitDefaults )
				{
					long iCount = pUnitDefaults->GetCount( ANSI8("SpecialViewRange") );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pUnitDefaults->GetItem( ANSI8("SpecialViewRange"), i );
						if( pItem )
						{
							InvokeUnitDefaultViewRange( CString( pItem->GetValue(ANSI8("UnitTag"))), atof(pItem->GetValue(ANSI8("Range"))) );
						}
					}
				}

			//
			// Unit Templates
			//
				// Add as a Build Option
				CBuildOption* pBuildOption = new CBuildOption();
				pBuildOption->SetBuildTargetToMoney();
				pBuildOption->SetBuildOptionSet( this );
				this->AddBuildOption( pBuildOption );

				CBCXMLItem* pUnits = pBody->GetItem( ANSI8("Units") );
				if( pUnits )
				{
					POSITION pos = pUnits->m_Items.GetHeadPosition();
					while( pos )
					{
						CBCXMLItem* pItem = pUnits->m_Items.GetNext( pos );
						if( pItem->m_strKey == ANSI8("Unit") )
						{
							CUnitTemplateB* pUnitTemplate = new CUnitTemplateB( this );
							pUnitTemplate->ReadXMLData( this, pItem );
							pUnitTemplate->SetIndex( iCurrentUnitTemplateIndex );
							iCurrentUnitTemplateIndex++;

							m_UnitTemplateList.AddTail( pUnitTemplate );

							/*
							CItemAndUnitsubset* pItemPlus = GetAllowUnitObj_old( pUnitTemplate->GetInternalName() );
							//CUnitsubsetPermission* pItemPlus = GetAllowUnitObj( pUnitTemplate->GetInternalName() );
							if( pItemPlus )
							{
								pUnitTemplate->GetAllowUnitsubsetObj()->Copy( pItemPlus );
							}
							*/

							// Add as a Build Option
							CBuildOption* pBuildOption = new CBuildOption();
							pBuildOption->SetBuildOptionSet( this );
							pBuildOption->SetBuildTargetToUnit( pUnitTemplate );
							this->AddBuildOption( pBuildOption );
						}
					}
				}
				SetNumValuesOfUnitTemplates();
				CalculateWhichUnitsAreSubmarines();

				// Temporary
				/*
				if( m_Allow_UnitList.IsEmpty() )
				{
					POSITION pos = m_UnitTemplateList.GetHeadPosition();
					while( pos )
					{
						CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
						CItemAndUnitsubset* pItemPlus = new CItemAndUnitsubset( this );
						pItemPlus->m_strItemName = pUnitTemplate->GetInternalName();
						pItemPlus->m_bListContainsPositiveItems = false;
						pItemPlus->SwitchPositiveNegative();
						m_Allow_UnitList.AddTail( pItemPlus );
					}
				}
				*/

			//
			// Buildings
			//
				CBCXMLItem* pBuildings = pBody->GetItem( ANSI8("Buildings") );
				if( pBuildings )
				{
					long iCount = pBuildings->GetCount( ANSI8("Building") );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pBuilding = pBuildings->GetItem( ANSI8("Building"), i );
						if( pBuilding )
						{
							CBuildingDescription* pBuildingDescription = new CBuildingDescription( this );
							pBuildingDescription->ReadXMLData( pBuilding );
							m_BuildingDescriptionList.AddTail( pBuildingDescription );

							/*
							CItemAndUnitsubset* pItemPlus = GetAllowBuildingObj_old( pBuildingDescription->GetInternalName() );
							if( pItemPlus )
							{
								pBuildingDescription->GetAllowUnitsubsetObj()->Copy( pItemPlus );
							}
							*/

							// Add as a Build Option
							CBuildOption* pBuildOption = new CBuildOption();
							pBuildOption->SetBuildOptionSet( this );
							pBuildOption->SetBuildTargetToBuilding( pBuildingDescription );
							this->AddBuildOption( pBuildOption );
						}
					}
				}

				// Temporary
				/*
				if( m_Allow_BuildingList.IsEmpty() )
				{
					POSITION pos = m_BuildingDescriptionList.GetHeadPosition();
					while( pos )
					{
						CBuildingDescription* pBuildingDescription = m_BuildingDescriptionList.GetNext( pos );
						CItemAndUnitsubset* pItemPlus = new CItemAndUnitsubset( this );
						pItemPlus->m_strItemName = pBuildingDescription->GetInternalName();
						pItemPlus->m_bListContainsPositiveItems = false;
						pItemPlus->SwitchPositiveNegative();
						m_Allow_BuildingList.AddTail( pItemPlus );
					}
				}
				*/

			//
			// Militia units
			//
				CBCXMLItem* pMilitia = pBody->GetItem( ANSI8("Militia") );
				if( pMilitia )
				{
					long iCount = pMilitia->GetCount( ANSI8("Unit") );
					for( long i=0; i<iCount; i++ )
					{
						CString strMilitiaUnit; strMilitiaUnit = pMilitia->GetValue( ANSI8("Unit"), i );
						m_InitialMilitiaUnitList.AddTail( strMilitiaUnit );
					}
				}
			//
			// Technology
			//
				CBCXMLItem* pTechnology = pBody->GetItem( ANSI8("Technology") );
				if( pTechnology )
				{
					long iCount = pTechnology->GetCount( ANSI8("TechDesc") );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pTechnology->GetItem( ANSI8("TechDesc"), i );
						CTechnologyDesc* pTechDesc = new CTechnologyDesc( this );
						pTechDesc->ReadXMLData( pItem );

						/*
						CItemAndUnitsubset* pItemPlus = GetAllowTechnologyObj_old( pTechDesc->GetName() );
						if( pItemPlus ){ pTechDesc->GetAllowUnitsubsetObj()->Copy( pItemPlus ); }
						pTechDesc->GetAllowUnitsubsetObj()->SwitchPositiveNegative();
						*/

						m_TechnologyList.AddTail( pTechDesc );
					}
				}
				CBCXMLItem* pTechTree = pBody->GetItem( ANSI8("TechTree") );
				if( pTechTree )
				{
					long iCount = pTechTree->GetCount( ANSI8("Tech") );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pTechTree->GetItem( ANSI8("Tech"), i );
						CTechTreeNode* pTechNode = new CTechTreeNode( this );
						pTechNode->ReadXMLData( pItem );
						//m_TechTreeHeadNodes.AddTail( pTechNode );
						//m_TechTreeNodes.AddTail( pTechNode );
					}
					// Read the Tech tree so I know the height of each node
					POSITION pos = m_TechTreeNodes.GetHeadPosition();
					while( pos )
					{
						CTechTreeNode* pTreeNode = m_TechTreeNodes.GetNext( pos );
						//if( pTreeNode->m_ParentNodes.IsEmpty() )
						if( pTreeNode->m_pParentNode == NULL )
						{
							pTreeNode->CalculateHeightOfChildren();
						}
					}
					/*
					POSITION pos = m_TechTreeHeadNodes.GetHeadPosition();
					while( pos )
					{
						CTechTreeNode* pTreeNode = m_TechTreeHeadNodes.GetNext( pos );
						pTreeNode->CalculateHeightOfChildren();
					}
					*/
				}

				// Calculate the PrereqTech values
				POSITION pos = m_TechnologyList.GetHeadPosition();
				while( pos )
				{
					CTechnologyDesc* pTechDesc = m_TechnologyList.GetNext( pos );
					pTechDesc->CalculatePrereqTechCost2();
				}
			//
			// Analysis
			//
				CBCXMLItem* pAnalysisSet = pBody->GetItem( ANSI8("AnalysisSet") );
				if( pAnalysisSet )
				{
					long iCount = pAnalysisSet->GetCount( ANSI8("Analysis") );
					for( long i=0; i<iCount; i++ )
					{
						CBCXMLItem* pItem = pAnalysisSet->GetItem( ANSI8("Analysis"), i );
						CAnalysisUnitTemplateList* pAnalysis = new CAnalysisUnitTemplateList();
						pAnalysis->ReadXMLData( pItem );
						m_AnalysisList.AddTail( pAnalysis );
					}
				}

		}

		// Make sure all the upgrade information is good
		pos = m_UnitTemplateList.GetHeadPosition();
		while( pos )
		{
			CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
			if( pUnitTemplate )
			{
				CString strUpgrade = pUnitTemplate->GetGenericUpgrade();
				CUnitTemplate* pUpgrade = GetUnitTemplate( strUpgrade );
				if( pUpgrade == NULL || pUnitTemplate == pUpgrade )
				{
					pUnitTemplate->SetGenericUpgrade( _T("") );
				}
				POSITION pos2 = pUnitTemplate->GetUnitsubsetUpgradeList()->GetHeadPosition();
				while( pos2 )
				{
					CUnitsubsetUpgrade* pUnitsubsetUpgrade = pUnitTemplate->GetUnitsubsetUpgradeList()->GetNext( pos2 );
					CUnitTemplate* pUpgrade = GetUnitTemplate( pUnitsubsetUpgrade->m_strUpgrade );
					if( pUpgrade == NULL || pUnitTemplate == pUpgrade )
					{
						pUnitTemplate->RemoveUnitsubsetUpgrade( pUnitsubsetUpgrade->m_strUnitsubset );
					}
				}
			}
		}
	}
	return true;
}

void  CUnitset::SetNumValuesOfUnitTemplates()
{
	long iNumValue = 1;
	POSITION pos = m_UnitTemplateList.GetHeadPosition();
	while( pos )
	{
		CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
		// Assign a Num Value
		pUnitTemplate->SetNumValue( iNumValue );
		iNumValue++;
	}
}

/*
void  CUnitset::LoadAnimationTemplates()
{
	CString strFileToOpenForAnimationData = g_pApp->GetBaseDirectory() + "\\Data\\Unitsets\\Official\\Animation\\Animation.desc";

	CString strRelativePathToSound = "Data\\Sound\\";

	CString strLine;
	CString strKey;
	CString strData;
	CAnimationTemplate* pAnimationTemplate = NULL;
	CString strBaseFilenameToAnimation;

	CStdioFile file;
	if( file.Open( strFileToOpenForAnimationData, CFile::modeRead | CFile::typeText ) )
	{
		while( file.ReadString( strLine ) )
		{
			if( strLine.IsEmpty() ) continue;

			strKey = CBCString::GetEverythingBefore( strLine, "=" );
			strKey.TrimLeft( " " );
			strKey.TrimRight( " " );

			strData = CBCString::GetEverythingAfter( strLine, "=" );
			strData.TrimLeft( " " );
			strData.TrimRight( " " );

			if( CBCString::BeginsWith( strKey, "//" ) ) continue;

			if( strKey == "AnimationSequence" )
			{
				// Load the previous one
				if( pAnimationTemplate )
				{
					pAnimationTemplate->LoadPNGSequence();
					pAnimationTemplate->LoadSound();
					g_pBitmapManager->m_AnimationTemplateList.AddTail( pAnimationTemplate );
					pAnimationTemplate = NULL;
				}

				strBaseFilenameToAnimation = g_pCommonState->GetBuildOptions()->GetRelativeBasePath() + 
					"\\Animation\\" + strData + "\\" + strData;
				pAnimationTemplate = new CAnimationTemplate();
				pAnimationTemplate->SetName( strData );
				pAnimationTemplate->SetBaseFilename( strBaseFilenameToAnimation );
			}
			if( strKey == "AnimationSequenceImageOffsetX" )
			{
				if( pAnimationTemplate )
				{
					pAnimationTemplate->SetImageCenterX( _ttol( strData ) );
				}
			}
			if( strKey == "AnimationSequenceImageOffsetY" )
			{
				if( pAnimationTemplate )
				{
					pAnimationTemplate->SetImageCenterY( _ttol( strData ) );
				}
			}
			if( strKey == "AnimationSequenceCyclesInfinitely" )
			{
				if( pAnimationTemplate )
				{
					if( strData == "true" )
					{
						pAnimationTemplate->SetAnimationCyclesInfinitely( true );
					}
				}
			}
			if( strKey == "AnimationSequenceSound" )
			{
				if( pAnimationTemplate )
				{
					CString strPath;
					if( strData.Find( "%Sound%" ) != -1 )
					{
						ASSERT( false );
						strPath = strData;
						strPath.Replace( "%Sound%", strRelativePathToSound );
					}
					else if( strData.Find( "%CommonSounds%" ) != -1 )
					{
						ASSERT( false );
						strPath = strData;
						strPath.Replace( "%CommonSounds%", 
							g_pCommonState->GetBuildOptions()->GetRelativeBasePath() + "\\Common Sounds\\" );
					}
					else
					{
						strPath = strBaseFilenameToAnimation + "\\" + strData;
					}
					pAnimationTemplate->SetSound( strPath );
				}
			}
			//LoadPNGSequence
		}
	}
	//
	if( pAnimationTemplate )
	{
		pAnimationTemplate->LoadPNGSequence();
		pAnimationTemplate->LoadSound();
		g_pBitmapManager->m_AnimationTemplateList.AddTail( pAnimationTemplate );
		pAnimationTemplate = NULL;
	}
}
*/

/*
void  CUnitset::LoadAnimationTemplates()
{
	m_AnimationManager.LoadAnimationTemplates( m_AnimationsToLoad );
	return;

	/-*
	POSITION pos = m_AnimationsToLoad.GetHeadPosition();
	while( pos )
	{
		CString strAnimationName = m_AnimationsToLoad.GetNext( pos );

		CAnimationTemplate* pAnimationTemplate = LoadAnimationTemplate( strAnimationName );
		if( pAnimationTemplate )
		{
			m_AnimationTemplateList.AddTail( pAnimationTemplate );
		}
	}
	*-/

	/-*
	POSITION pos = m_AnimationTemplateList.GetHeadPosition();
	while( pos )
	{
		CAnimationTemplate* pAnimationTemplate = m_AnimationTemplateList.GetNext( pos );
		pAnimationTemplate->Load();
	}
	*-/

	return;  // We already pre-loaded this information (in the revised LoadUnitSet method)

	//CString strFileToOpenForAnimationData = g_pApp->GetBaseDirectory() + "\\Data\\Unitsets\\Official\\Animation\\Animation.desc";
	CString strFileToOpenForAnimationData = g_pApp->GetBaseDirectory() + "\\Data\\Unitsets\\" + m_strLocalFile + "\\Animations.desc"; // "\\Data\\Unitsets\\Official\\Animations.desc";

	CStdioFile file;
	if( file.Open( strFileToOpenForAnimationData, CFile::modeRead | CFile::typeText ) )
	{
		CStringDataBlock StringDataBlock2;
		StringDataBlock2.Read( &file );

		POSITION pos = StringDataBlock2.m_HeadNode.m_ChildList.GetHeadPosition();
		while( pos )
		{
			CStringDataItem* pChild = StringDataBlock2.m_HeadNode.m_ChildList.GetNext( pos );

			if( CBCString::BeginsWith( pChild->m_strKey, "//" ) ) continue;

			if( pChild->m_strKey == "LoadAnimation" )
			{
				//m_AnimationsToLoad.AddTail( pChild->m_strValue );
				/*
				CAnimationTemplate* pAnimationTemplate = LoadAnimationTemplate( pChild->m_strValue );
				if( pAnimationTemplate )
				{
					//m_AnimationTemplateList.AddTail( pAnimationTemplate );
				}
				*-/
			}
			if( pChild->m_strKey == "Keyword" )
			{
				CString strKeyword = pChild->m_strValue;
				CCompoundAnimationDesc* pCompoundDesc = new CCompoundAnimationDesc();
				pCompoundDesc->m_strKeyword = strKeyword;
				GetAnimationManager()->AddCompoundAnimation( pCompoundDesc );

				POSITION pos2 = pChild->m_ChildList.GetHeadPosition();
				while( pos2 )
				{
					CStringDataItem* pChild2 = pChild->m_ChildList.GetNext( pos2 );
					if( pChild2->m_strKey == "AimAheadOfTarget" )
					{
						pCompoundDesc->m_fAimAheadOfTarget = _tstof( pChild2->m_strValue );
					}
					if( pChild2->m_strKey == "IfOnLand then Keyword" )
					{
						pCompoundDesc->m_strAliasIfOnLand = pChild2->m_strValue;
					}
					if( pChild2->m_strKey == "IfOnWater then Keyword" )
					{
						pCompoundDesc->m_strAliasIfOnWater = pChild2->m_strValue;
					}
					if( pChild2->m_strKey == "Animation" )
					{
						CSimpleAnimationDesc* pSimpleDesc = new CSimpleAnimationDesc();
						pCompoundDesc->m_AnimationList.AddTail( pSimpleDesc );
						pSimpleDesc->m_strAnimation = pChild2->m_strValue;
						POSITION pos3 = pChild2->m_ChildList.GetHeadPosition();
						while( pos3 )
						{
							CStringDataItem* pChild3 = pChild2->m_ChildList.GetNext( pos3 );
							if( pChild3->m_strKey == "Begin" )
							{
								pSimpleDesc->m_fStartTime = _tstof( pChild3->m_strValue );
							}
							/*
							if( pChild3->m_strKey == "OffsetX" )
							{
								pSimpleDesc->m_fOffsetX = _tstof( pChild3->m_strValue );
							}
							if( pChild3->m_strKey == "OffsetY" )
							{
								pSimpleDesc->m_fOffsetY = _tstof( pChild3->m_strValue );
							}
							*-/
							if( pChild3->m_strKey == "AnimationOffset" )
							{
								CString strData = pChild3->m_strValue;
								if( strData != "" )
								{
									float fValX = _tstof( strData );
									pSimpleDesc->m_fOffsetX = _tstof( strData );

									long iFind = strData.Find( "," );
									strData = strData.Right( strData.GetLength()-(iFind+1) );

									float fValY = _tstof( strData );
									//iFind = strData.Find( ";" );
									//strData = strData.Right( strData.GetLength()-(iFind+1) );
									pSimpleDesc->m_fOffsetY = _tstof( strData );
								}
							}

							if( pChild3->m_strKey == "Duration" )
							{
								pSimpleDesc->m_fDuration = _tstof( pChild3->m_strValue );
							}
							if( pChild3->m_strKey == "Size" )
							{
								pSimpleDesc->m_fSize = _tstof( pChild3->m_strValue );
							}
						}
					}
					if( pChild2->m_strKey == "AnimationOffset" )
					{
						CString strData = pChild2->m_strValue;
						while( strData != "" )
						{
							long iValX = _ttol( strData );
							long iFind = strData.Find( "," );
							strData = strData.Right( strData.GetLength()-(iFind+1) );
							long iValY = _ttol( strData );
							iFind = strData.Find( ";" );
							strData = strData.Right( strData.GetLength()-(iFind+1) );
							if( iFind == -1 ){ strData = ""; }

							pCompoundDesc->m_AnimationOffsetList.AddTail( CPoint( iValX,iValY ) );
						}
					}
					//CSimpleAnimationDesc* pSimpleDesc = new CSimpleAnimationDesc();
					//pSimpleDesc->m_strAnimation = "Flash";
					//pSimpleDesc->m_fFlashDuration = 8.0f;
					//pSimpleDesc->m_fFlashSize = 120.0f;

				}
			}
		}
	}
	else
	{
		CString strText;
		strText.Format( "Error: Could not open file %s", strFileToOpenForAnimationData );
		AfxMessageBox( strText );
	}

	/*
	CString strLine;
	CString strKey;
	CString strData;
	CAnimationTemplate* pAnimationTemplate = NULL;
	CString strBaseFilenameToAnimation;

	CStdioFile file;
	if( file.Open( strFileToOpenForAnimationData, CFile::modeRead | CFile::typeText ) )
	{
		while( file.ReadString( strLine ) )
		{
			if( strLine.IsEmpty() ) continue;

			strKey = CBCString::GetEverythingBefore( strLine, "=" );
			strKey.TrimLeft( " " );
			strKey.TrimRight( " " );

			strData = CBCString::GetEverythingAfter( strLine, "=" );
			strData.TrimLeft( " " );
			strData.TrimRight( " " );

			if( CBCString::BeginsWith( strKey, "//" ) ) continue;

			if( strKey == "LoadAnimation" )
			{
				CAnimationTemplate* pAnimationTemplate = LoadAnimationTemplate( strData );
				if( pAnimationTemplate )
				{
					g_pBitmapManager->m_AnimationTemplateList.AddTail( pAnimationTemplate );
				}
			}
			if( strKey == "Keyword" )
			{
				CString strName = strData;
			}
		}
	}
	else
	{
		CString strText;
		strText.Format( "Error: Could not open file %s", strFileToOpenForAnimationData );
		AfxMessageBox( strText );
	}
	*-/
}
*/

/*
CAnimationTemplate* CUnitset::LoadAnimationTemplate( CString strName )
{
	//CString strRelativePathToAnimationFiles = "\\Data\\Unitsets\\Official\\Animation\\" + strName + "\\";
	CString strRelativePathToAnimationFiles = "\\Data\\Images\\Animations\\" + strName + "\\";
	CString strFullPathToAnimationFiles = g_pApp->GetBaseDirectory() + strRelativePathToAnimationFiles;
	CString strFileToOpenForDescription = strFullPathToAnimationFiles + "_ImageDesc.anim";
	//CString strFileToOpenForAnimationData = g_pApp->GetBaseDirectory() + "\\Data\\Unitsets\\Official\\Animation\\" + strName + "\\_ImageDesc.anim";

	CString strRelativePathToSound = "Data\\Sound\\";

	CString strLine;
	CString strKey;
	CString strData;
	CAnimationTemplate* pAnimationTemplate = new CAnimationTemplate();
	CString strBaseFilenameToAnimation;

	CStdioFile file;
	if( file.Open( strFileToOpenForDescription, CFile::modeRead | CFile::typeText ) )
	{
		while( file.ReadString( strLine ) )
		{
			if( strLine.IsEmpty() ) continue;

			strKey = CBCString::GetEverythingBefore( strLine, "=" );
			strKey.TrimLeft( " " );
			strKey.TrimRight( " " );

			strData = CBCString::GetEverythingAfter( strLine, "=" );
			strData.TrimLeft( " " );
			strData.TrimRight( " " );

			if( CBCString::BeginsWith( strKey, "//" ) ) continue;

			if( strKey == "AnimationSequence" )
			{
				/-*
				// Load the previous one
				if( pAnimationTemplate )
				{
					pAnimationTemplate->LoadPNGSequence();
					pAnimationTemplate->LoadSound();
					g_pBitmapManager->m_AnimationTemplateList.AddTail( pAnimationTemplate );
					pAnimationTemplate = NULL;
				}
				*-/

				//strBaseFilenameToAnimation = g_pCommonState->GetBuildOptions()->GetRelativeBasePath() + 
				//	"\\Animation\\" + strData + "\\" + strData;
				//strBaseFilenameToAnimation = strRelativePathToAnimationFiles + strData;
				//pAnimationTemplate = new CAnimationTemplate();
				pAnimationTemplate->SetName( strData );
				pAnimationTemplate->SetBaseFilename( strRelativePathToAnimationFiles + strData );
			}
			if( strKey == "AnimationSequenceImageOffsetX" )
			{
				if( pAnimationTemplate )
				{
					pAnimationTemplate->SetImageCenterX( _ttol( strData ) );
				}
			}
			if( strKey == "AnimationSequenceImageOffsetY" )
			{
				if( pAnimationTemplate )
				{
					pAnimationTemplate->SetImageCenterY( _ttol( strData ) );
				}
			}
			if( strKey == "AnimationSequenceCyclesInfinitely" )
			{
				if( pAnimationTemplate )
				{
					if( strData == "true" )
					{
						pAnimationTemplate->SetAnimationCyclesInfinitely( true );
					}
				}
			}
			if( strKey == "AnimationSequenceSound" )
			{
				if( pAnimationTemplate )
				{
					CString strPath;
					if( strData.Find( "%Sound%" ) != -1 )
					{
						strPath = strData;
						strPath.Replace( "%Sound%", strRelativePathToSound );
					}
					else if( strData.Find( "%CommonSounds%" ) != -1 )
					{
						ASSERT( false );
						strPath = strData;
						/*
						strPath.Replace( "%CommonSounds%", 
							g_pCommonState->GetBuildOptions()->GetRelativeBasePath() + "\\Common Sounds\\" );
						*-/
					}
					else
					{
						strPath = strBaseFilenameToAnimation + "\\" + strData;
					}
					pAnimationTemplate->SetSound( strPath );
				}
			}
			//LoadPNGSequence
		}
	}
	else
	{
		CString strText;
		strText.Format( "Error: Could not open file %s", strFileToOpenForDescription );
		AfxMessageBox( strText );
		delete pAnimationTemplate;
		return NULL;
	}
	//
	pAnimationTemplate->LoadPNGSequence();
	pAnimationTemplate->LoadSound();
	return pAnimationTemplate;
}
*/

void  CUnitset::CalculateWhichUnitsAreSubmarines()
{
	CBCStopwatch2 Stopwatch;
	Stopwatch.Start();

	float fTotalSeaUnitViewDistance = 0.0f;
	long  iTotalCount = 0;
	ASSERT( m_UnitTemplateList.IsEmpty() == FALSE );
	POSITION pos = m_UnitTemplateList.GetHeadPosition();
	while( pos )
	{
		CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
		if( pUnitTemplate->IsSeaUnit() )
		{
			float fThisUnitTotal = 0.0f;
			long  iThisUnitCount = 0;
			POSITION pos2 = m_UnitTemplateList.GetHeadPosition();
			while( pos2 )
			{
				CUnitTemplate* pUnitTemplate2 = m_UnitTemplateList.GetNext( pos2 );
				float fViewRange = pUnitTemplate2->GetViewRange( pUnitTemplate );
				fTotalSeaUnitViewDistance += fViewRange;
				iTotalCount++;
				fThisUnitTotal += fViewRange;
				iThisUnitCount++;
			}
			if( iThisUnitCount > 0 )
			{
				float fThisUnitAverage = fThisUnitTotal/iThisUnitCount;
				pUnitTemplate->SetAverageViewedRange( fThisUnitAverage );
			}
		}
	}
	float fAverageSeaUnitViewDistance = 0.0f;
	if( iTotalCount > 0 )
	{
		fAverageSeaUnitViewDistance = fTotalSeaUnitViewDistance / iTotalCount;
	}

	//
	// Identify which units of mine are "submarines"
	//
	pos = m_UnitTemplateList.GetHeadPosition();
	while( pos )
	{
		CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
		if( pUnitTemplate->IsSeaUnit() )
		{
			if( pUnitTemplate->GetAverageViewedRange() < fAverageSeaUnitViewDistance/2.0f )
			{
				pUnitTemplate->IsSubmarine( true );
			}
		}
	}

	Stopwatch.Stop();
	float f = Stopwatch.GetDeltaSeconds();

	int h=0;

	/*
	float fTotalSeaUnitViewDistance = 0.0f;
	long iCount = 0;
	pos = m_AllUnitsInTheGameOrBuildableByMe.m_List.GetHeadPosition();
	while( pos )
	{
		CUnitTemplate* pUnitTemplate = m_AllUnitsInTheGameOrBuildableByMe.m_List.GetNext( pos );
		if( pUnitTemplate && pUnitTemplate->IsSeaUnit() )
		{
			//fTotalSeaUnitViewDistance += pUnitTemplate->GetUnitCombatCapability()->GetAverageVisibleRange();
			iCount++;
		}
	}
	float fAverageSeaUnitViewDistance = 0.0f;
	if( iCount > 0 )
	{
		fAverageSeaUnitViewDistance = fTotalSeaUnitViewDistance / iCount;

		pos = m_AllUnitsInTheGameOrBuildableByMe.m_List.GetHeadPosition();
		while( pos )
		{
			CUnitTemplate* pUnitTemplate = m_AllUnitsInTheGameOrBuildableByMe.m_List.GetNext( pos );
			if( pUnitTemplate && pUnitTemplate->IsSeaUnit() )
			{
				//float fViewDistance = pUnitTemplate->GetUnitCombatCapability()->GetAverageVisibleRange();
				if( fViewDistance < fAverageSeaUnitViewDistance*0.50f )
				{
					// This is a submarine
					m_SubmarineUnitsInTheGame.AddUnitTemplate( pUnitTemplate );
				}
			}
		}
	}
	*/
}

bool  CUnitset::CanBuild( long iPlayer, CAirfieldImprovement* pAirfieldImprovement, bool bAllowOldTechnologies )
{
	if( pAirfieldImprovement == NULL ){ return false; }

	CPlayer* pPlayer = GetCommonState()->GetPlayer( iPlayer );
	if( pPlayer == NULL ){ ASSERT( false ); return false; }

	CString strUnitsubset = pPlayer->GetUnitsubset();
	//CString pAirfieldImprovement

	// Can I *ever* build the unit?
	CString strAirfieldImprovement = pAirfieldImprovement->GetInternalName();
	if( GetAllowAirfieldImprovement( strUnitsubset, strAirfieldImprovement ) == false ) return false;

	// Can I *initially* build the unit?
	bool bCanBuild = false;
	POSITION pos = m_InitialCanBuildAirfieldImprovementList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildAirfieldImprovementList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
		{
			if( pUnitsubsetValue->m_strValue == strAirfieldImprovement )
			{
				return true;
			}
		}
	}

	// Check the technology to see if the player can build it
	if( pPlayer->IsHuman() )
	{
		CWorldDescPlayer* pWorldDescPlayer = GetCommonState()->GetWorldDescPlayerByPlayerNumber( iPlayer );
		if( pWorldDescPlayer )
		{
			pos = m_TechnologyList.GetHeadPosition();
			while( pos )
			{
				CTechnologyDesc* pTechNode = m_TechnologyList.GetNext( pos );
				bool bEnablesBuilding = pTechNode->EnablesAirfieldImprovement( strAirfieldImprovement );
				if( bEnablesBuilding )
				{
					if( pWorldDescPlayer->GetTechnologyHasBeenDiscovered( pTechNode->GetInternalName() ) )
					{
						return true;
					}
				}
			}
		}
	}
	CWorldDescServer* pWorldDescServer = GetCommonState()->GetWorldDescServer();
	if( pWorldDescServer )
	{
		CWorldDescPlayerProxy* pWorldDescPlayerProxy = pWorldDescServer->GetWorldDescPlayerProxy( iPlayer );
		if( pWorldDescPlayerProxy )
		{
			pos = m_TechnologyList.GetHeadPosition();
			while( pos )
			{
				CTechnologyDesc* pTechNode = m_TechnologyList.GetNext( pos );
				bool bEnablesBuilding = pTechNode->EnablesAirfieldImprovement( strAirfieldImprovement );
				if( bEnablesBuilding )
				{
					if( pWorldDescPlayerProxy->GetTechnologyHasBeenDiscovered( pTechNode->GetInternalName() ) )
					{
						return true;
					}
				}
			}
		}
	}

	return false;
}

bool  CUnitset::CanBuild( long iPlayer, CBuildOption* pBuildOption, bool bAllowOldTechnologies )
{
	CPlayer* pPlayer = GetCommonState()->GetPlayer( iPlayer );
	if( pPlayer == NULL ) return true;

	CString strUnitsubset = pPlayer->GetUnitsubset();

	//if( pBuildOption->IsIncProd() ) return true;
	if( pBuildOption->IsMoney() ) return true;

	if( pBuildOption->IsABuilding() )
	{
		CString strBuilding = pBuildOption->GetBuildingDescription()->GetInternalName();
		return CanBuildBuilding( iPlayer, strBuilding );
	}
	if( pBuildOption->IsAUnit() )
	{
		CString strUnit = pBuildOption->GetUnitTemplate()->GetInternalName();
		CString strUpgradedUnit = pBuildOption->GetUnitTemplate()->GetUnitsubsetUpgrade( strUnitsubset );

		if( bAllowOldTechnologies || strUpgradedUnit == _T("") )
		{
			return CanBuildUnit( iPlayer, strUnit );
		}
		else
		{
			return CanBuildUnit( iPlayer, strUnit ) && !CanBuildUnit( iPlayer, strUpgradedUnit );
		}
	}
	ASSERT( false );
	return false;
}

//bool  CUnitset::CanBuild( CString strUnitsubset, CBuildOption* pBuildOption, bool bAllowOldTechnologies )
/*
bool  CUnitset::CanBuild_old( long iPlayer, CBuildOption* pBuildOption, bool bAllowOldTechnologies )
{
	if( pBuildOption->IsIncProd() ) return true;
	if( pBuildOption->IsMoney() ) return true;

	// Right now, I'm using this function to figure out what should appear on the
	//   CityDialog display.  The AI also uses it to figure out what it can build.  
	//   I can change this, but I'd need access to the server to figure out what other players can build
	//ASSERT( iPlayer == g_pGameAppState->GetWorldDescPlayer()->GetPlayerMe()->GetPlayerNumber() );
	//if( iPlayer == g_pGameAppState->GetWorldDescPlayer()->GetPlayerMe()->GetPlayerNumber() )
	{
		//CString strUnitsubset = g_pGameAppState->GetWorldDescPlayer()->GetPlayerMe()->GetUnitsubset();
		CWorldDescPlayer* pWorldDescPlayer = GetCommonState()->GetWorldDescPlayerByPlayerNumber( iPlayer );
		ASSERT( pWorldDescPlayer );
		if( pWorldDescPlayer == NULL ) return false;

		CPlayer* pPlayer = GetCommonState()->GetPlayer( iPlayer );
		ASSERT( pPlayer );
		if( pPlayer == NULL ) return false;

		CString strUnitsubset = pPlayer->GetUnitsubset();

		bool bIsEnabled = false;
		bool bIsDisabled = false;

		if( pBuildOption->IsABuilding() )
		{
			CString strBuilding = pBuildOption->GetBuildingDescription()->GetInternalName();

			if( GetAllowBuilding( strUnitsubset, strBuilding ) == false ) return false;

			//
			POSITION pos = m_InitialCanBuildBuildingList.GetHeadPosition();
			while( pos )
			{
				CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
				//if( pUnitsubsetValue->m_strUnitsubset == "" ||
				//	pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
				if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
				{
					if( pUnitsubsetValue->m_strValue == strBuilding )
					{
						bIsEnabled = true;
					}
				}
			}
			// Now iterate over the technology
			pos = m_TechnologyList.GetHeadPosition();
			while( pos )
			{
				CTechnologyDesc* pTechNode = m_TechnologyList.GetNext( pos );
				bool bEnablesBuilding = pTechNode->EnablesBuilding( strBuilding );
				bool bDisablesBuilding = pTechNode->DisablesBuilding( strBuilding );
				if( bEnablesBuilding || bDisablesBuilding )
				{
					if( pWorldDescPlayer->GetTechnologyHasBeenDiscovered( pTechNode->GetName() ) )
					{
						if( bEnablesBuilding ) bIsEnabled = true;
						if( bDisablesBuilding ) bIsDisabled = true;
					}
				}
			}
		}
		if( pBuildOption->IsAUnit() )
		{
			//CString strUnitFileIdentifier = pBuildOption->GetUnitTemplate()->GetFileIdentifier();
			CString strUnit = pBuildOption->GetUnitTemplate()->GetInternalName();
			CString strUpgradedUnit = pBuildOption->GetUnitTemplate()->GetUpgrade();

			if( GetAllowUnit( strUnitsubset, strUnit ) == false ) return false;

			POSITION pos = m_InitialCanBuildUnitList.GetHeadPosition();
			while( pos )
			{
				CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
				if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
				{
					if( pUnitsubsetValue->m_strValue == strUnit )
					{
						bIsEnabled = true;
					}
				}
			}

			// Now iterate over the technology
			pos = m_TechnologyList.GetHeadPosition();
			while( pos )
			{
				CTechnologyDesc* pTechNode = m_TechnologyList.GetNext( pos );
				bool bEnablesUnit = pTechNode->EnablesUnit( strUnit );
				bool bDisablesUnit = pTechNode->DisablesUnit( strUnit );
				if( bEnablesUnit || bDisablesUnit )
				{
					if( pWorldDescPlayer->GetTechnologyHasBeenDiscovered( pTechNode->GetName() ) )
					{
						if( bEnablesUnit ) bIsEnabled = true;
						if( bDisablesUnit ) bIsDisabled = true;
					}
				}
			}
		}
		if( bAllowOldTechnologies ){ return bIsEnabled; }
		return ( bIsEnabled && bIsDisabled == false );
	}
	return false;
}
*/

bool  CUnitset::CanBuildUnit( long iPlayer, CString strUnit )
{
	CPlayer* pPlayer = GetCommonState()->GetPlayer( iPlayer );
	if( pPlayer == NULL ){ ASSERT( false ); return false; }

	CString strUnitsubset = pPlayer->GetUnitsubset();

	// Can I *ever* build the unit?
	if( GetAllowUnit( strUnitsubset, strUnit ) == false ) return false;

	// Can I *initially* build the unit?
	bool bCanBuild = false;
	POSITION pos = m_InitialCanBuildUnitList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
		{
			if( pUnitsubsetValue->m_strValue == strUnit )
			{
				return true;
			}
		}
	}

	// Check the technology to see if the player can build it
	/*
	CPlayerTechnologySet* pTechnologySet = NULL;
	if( GetCommonState()->GetWorldDescServer() )
	{
		GetCommonState()->GetWorldDescServer()->GetTechnologyHasBeenDiscovered( iPlayer, 
	}
	else
	{
		ASSERT( g_pGameAppState );
		CWorldDescPlayer* pWorldDescPlayer = g_pGameAppState->GetWorldDescPlayer();
		CPlayerTechnologyObject* pObject = pWorldDescPlayer->GetPlayerTechnologySet()->GetPlayerTechnologyObject( iPlayer );
		pObject->TechnologyExists( 
	}
	*/
	pos = m_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CTechnologyDesc* pTechNode = m_TechnologyList.GetNext( pos );
		bool bEnablesUnit = pTechNode->EnablesUnit( strUnit );
		if( bEnablesUnit )
		{
			if( GetCommonState()->GetWorldDescServer() )
			{
				if( GetCommonState()->GetWorldDescServer()->GetTechnologyHasBeenDiscovered( iPlayer, pTechNode->GetInternalName() ) )
				{
					return true;
				}
			}
			else
			{
				//ASSERT( g_pGameAppState );
				ASSERT( GetCommonState() );
				ASSERT( GetCommonState()->GetLocalPlayerWorldDescList()->IsEmpty() == FALSE );

				//CWorldDescPlayer* pWorldDescPlayer = g_pCommonState->GetWorldDescPlayerByPlayerNumber( iPlayer );
				//if( pWorldDescPlayer == NULL )
				//{
				//	pWorldDescPlayer = GetCommonState()->GetLocalHumanPlayerWorldDesc();
				//}
				//if( pWorldDescPlayer == NULL )
				//{
				//	pWorldDescPlayer = GetCommonState()->GetLocalPlayerWorldDescList()->GetHead();
				//}
				CWorldDescPlayer* pWorldDescPlayer = g_pCommonState->GetLocalPlayerWorldDescList()->GetHead();
				ASSERT( pWorldDescPlayer );
				//CWorldDescPlayer* pWorldDescPlayer = GetCommonState()->GetLocalPlayerWorldDescList()->GetHead();
				//CWorldDescPlayer* pWorldDescPlayer = g_pGameAppState->GetWorldDescPlayer();
				CPlayerTechnologyObject* pObject = pWorldDescPlayer->GetPlayerTechnologySet()->GetPlayerTechnologyObject( iPlayer );
				if( pObject && pObject->TechnologyExists( pTechNode->GetInternalName() ) )
				{
					return true;
				}
				/*
				if( pWorldDescPlayer->GetTechnologyHasBeenDiscovered( pTechNode->GetName() ) )
				{
					return true;
				}
				*/
			}
		}
	}

	/*
	CWorldDescPlayer* pWorldDescPlayer = GetCommonState()->GetWorldDescPlayerByPlayerNumber( iPlayer );
	if( pWorldDescPlayer == NULL ){ ASSERT( false ); return false; }

	pos = m_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CTechnologyDesc* pTechNode = m_TechnologyList.GetNext( pos );
		bool bEnablesUnit = pTechNode->EnablesUnit( strUnit );
		//bool bDisablesUnit = pTechNode->DisablesUnit( strUnit );
		if( bEnablesUnit )
		{
			if( GetCommonState()->GetWorldDescServer() )
			{
				if( GetCommonState()->GetWorldDescServer()->GetTechnologyHasBeenDiscovered( iPlayer, pTechNode->GetName() ) )
				{
					return true;
				}
			}
			else
			{
				if( pWorldDescPlayer->GetTechnologyHasBeenDiscovered( pTechNode->GetName() ) )
				{
					return true;
				}
			}
		}
	}
	*/

	return false;
}

bool  CUnitset::CanBuildBuilding( long iPlayer, CString strBuilding )
{
	CPlayer* pPlayer = GetCommonState()->GetPlayer( iPlayer );
	if( pPlayer == NULL ){ ASSERT( false ); return false; }
/*
	#ifdef _DEBUG
	if( strBuilding == _T("Capitol") )
	{
		int g=0;
	}
	#endif
 */
	CString strUnitsubset = pPlayer->GetUnitsubset();

	// Can I *ever* build the unit?
	if( GetAllowBuilding( strUnitsubset, strBuilding ) == false ) return false;

	// Can I *initially* build the unit?
	bool bCanBuild = false;
	POSITION pos = m_InitialCanBuildBuildingList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
		{
			if( pUnitsubsetValue->m_strValue == strBuilding )
			{
				return true;
			}
		}
	}

	// Check the technology to see if the player can build it
	if( pPlayer->IsHuman() )
	{
		CWorldDescPlayer* pWorldDescPlayer = GetCommonState()->GetWorldDescPlayerByPlayerNumber( iPlayer );
		if( pWorldDescPlayer )
		{
			pos = m_TechnologyList.GetHeadPosition();
			while( pos )
			{
				CTechnologyDesc* pTechNode = m_TechnologyList.GetNext( pos );
				bool bEnablesBuilding = pTechNode->EnablesBuilding( strBuilding );
				//bool bDisablesUnit = pTechNode->DisablesUnit( strUnit );
				if( bEnablesBuilding )
				{
					if( pWorldDescPlayer->GetTechnologyHasBeenDiscovered( pTechNode->GetInternalName() ) )
					{
						return true;
					}
				}
			}
		}
	}

	CWorldDescServer* pWorldDescServer = GetCommonState()->GetWorldDescServer();
	if( pWorldDescServer )
	{
		CWorldDescPlayerProxy* pWorldDescPlayerProxy = pWorldDescServer->GetWorldDescPlayerProxy( iPlayer );
		if( pWorldDescPlayerProxy )
		{
			pos = m_TechnologyList.GetHeadPosition();
			while( pos )
			{
				CTechnologyDesc* pTechNode = m_TechnologyList.GetNext( pos );
				bool bEnablesBuilding = pTechNode->EnablesBuilding( strBuilding );
				if( bEnablesBuilding )
				{
					if( pWorldDescPlayerProxy->GetTechnologyHasBeenDiscovered( pTechNode->GetInternalName() ) )
					{
						return true;
					}
				}
			}
		}
	}

	return false;
}

bool  CUnitset::CanEverBuild( CString strUnitsubset, CUnitTemplate* pUnitTemplate )
{
	CString strUnit = pUnitTemplate->GetInternalName();

	// Check the "Allowed" state
	if( GetAllowUnit( strUnitsubset, pUnitTemplate->GetInternalName() ) == false ) return false;

	// Check the initially allowed state
	POSITION pos = m_InitialCanBuildUnitList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
		{
			if( pUnitsubsetValue->m_strValue == strUnit )
			{
				return true;
			}
		}
	}
	// Now iterate over the technology
	pos = m_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CTechnologyDesc* pTechDesc = m_TechnologyList.GetNext( pos );
		bool bEnablesUnit = pTechDesc->EnablesUnit( strUnit );
		if( bEnablesUnit && GetAllowTechnology( strUnitsubset, pTechDesc->GetInternalName() ) )
		{
			return true;
		}
	}
	return false;
}

//bool  CUnitset::CanBuildInitially( CString strUnitsubset, CBuildOption* pBuildOption )
bool  CUnitset::CanInitiallyBuild( CString strUnitsubset, CBuildOption* pBuildOption )
{
	//if( pBuildOption->IsIncProd() ) return true;
	if( pBuildOption->IsMoney() ) return true;
	//
	if( strUnitsubset == _T("") ) return false;

	bool bIsEnabled = false;
	bool bIsDisabled = false;

	if( pBuildOption->IsABuilding() )
	{
		CString strBuildingIdentifier = pBuildOption->GetBuildingDescription()->GetInternalName();
		POSITION pos = m_InitialCanBuildBuildingList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
			//if( pUnitsubsetValue->m_strUnitsubset == "" ||
			//	pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				if( pUnitsubsetValue->m_strValue == strBuildingIdentifier )
				{
					return true;
					//bIsEnabled = true;
				}
			}
		}
		// Now iterate over the technology
		/*
		pos = m_TechnologyList.GetHeadPosition();
		while( pos )
		{
			CTechnologyDesc* pTechNode = m_TechnologyList.GetNext( pos );
			bool bEnablesBuilding = pTechNode->EnablesBuilding( strBuildingIdentifier );
			bool bDisablesBuilding = pTechNode->DisablesBuilding( strBuildingIdentifier );
			if( bEnablesBuilding || bDisablesBuilding )
			{
				if( g_pGameAppState->GetWorldDescPlayer()->GetTechnologyHasBeenDiscovered( pTechNode->GetName() ) )
				{
					if( bEnablesBuilding ) bIsEnabled = true;
					if( bDisablesBuilding ) bIsDisabled = true;
				}
			}
		}
		*/
	}
	if( pBuildOption->IsAUnit() )
	{
		CString strUnit = pBuildOption->GetUnitTemplate()->GetInternalName();

		POSITION pos = m_InitialCanBuildUnitList.GetHeadPosition();
		while( pos )
		{
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				if( pUnitsubsetValue->m_strValue == strUnit ||
					pUnitsubsetValue->m_strValue == _T("") )
				{
					return true;
					//bIsEnabled = true;
				}
			}
		}
		// Now iterate over the technology
		/*
		pos = m_TechnologyList.GetHeadPosition();
		while( pos )
		{
			CTechnologyDesc* pTechNode = m_TechnologyList.GetNext( pos );
			bool bEnablesUnit = pTechNode->EnablesUnit( strUnitFileIdentifier );
			bool bDisablesUnit = pTechNode->DisablesUnit( strUnitFileIdentifier );
			if( bEnablesUnit || bDisablesUnit )
			{
				if( g_pGameAppState->GetWorldDescPlayer()->GetTechnologyHasBeenDiscovered( pTechNode->GetName() ) )
				{
				//if( pTechNode->GetHasBeenDiscovered( strNationName ) )
				//{
					if( bEnablesUnit ) bIsEnabled = true;
					if( bDisablesUnit ) bIsDisabled = true;
				}
			}
		}
		*/
	}
	//if( bAllowOldTechnologies ){ return bIsEnabled; }
	//return ( bIsEnabled && bIsDisabled == false );
	return false;
}

bool  CUnitset::CanInitiallyBuild( CString strUnitsubset, CUnitTemplate* pUnitTemplate )
{
	CString strUnit = pUnitTemplate->GetInternalName();

	POSITION pos = m_InitialCanBuildUnitList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
		{
			if( pUnitsubsetValue->m_strValue == strUnit ||
				pUnitsubsetValue->m_strValue == _T("") )
			{
				return true;
				//bIsEnabled = true;
			}
		}
	}
	return false;
}

bool  CUnitset::UnitsubsetExists( CString strUnitsubset )
{
	POSITION pos = m_UnitsubsetList.GetHeadPosition();
	while( pos )
	{
		CString strUnitsubsetInList = m_UnitsubsetList.GetNext( pos );
		if( strUnitsubset == strUnitsubsetInList ) return true;
	}
	return false;
}

void  CUnitset::DuplicateUnitsubset( CString strUnitsubsetToDuplicate, CString strUnitsubset )
{
	POSITION pos;

	// Clear the NewUnitsubset information
	{
		// Free Units, Technology
		pos = m_InitialFreeTechnologyList.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeTechnologyList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				delete pUnitsubsetValue;
				m_InitialFreeTechnologyList.RemoveAt( prevPos );
			}
		}
		pos = m_InitialFreeUnitCoastalCityList.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitCoastalCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				delete pUnitsubsetValue;
				m_InitialFreeUnitCoastalCityList.RemoveAt( prevPos );
			}
		}
		pos = m_InitialFreeUnitLandlockedCityList.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitLandlockedCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				delete pUnitsubsetValue;
				m_InitialFreeUnitLandlockedCityList.RemoveAt( prevPos );
			}
		}
		// Can Build Units, Buildings
		pos = m_InitialCanBuildUnitList.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				delete pUnitsubsetValue;
				m_InitialCanBuildUnitList.RemoveAt( prevPos );
			}
		}
		pos = m_InitialCanBuildBuildingList.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
			{
				delete pUnitsubsetValue;
				m_InitialCanBuildBuildingList.RemoveAt( prevPos );
			}
		}
		// Allow Research
		/*
		pos = m_Allow_TechnologyList.GetHeadPosition();
		while( pos )
		{
			CItemAndUnitsubset* pItemPlus = m_Allow_TechnologyList.GetNext( pos );
			pItemPlus->SetUnitsubsetToNegative( strUnitsubset );
		}
		*/
		pos = m_TechnologyList.GetHeadPosition();
		while( pos )
		{
			CTechnologyDesc* pTechnologyDesc = m_TechnologyList.GetNext( pos );
			pTechnologyDesc->GetAllowUnitsubsetObj()->SetUnitsubsetToNegative( strUnitsubset );
		}

		/*
		pos = m_Allow_UnitList.GetHeadPosition();
		while( pos )
		{
			CItemAndUnitsubset* pItemPlus = m_Allow_UnitList.GetNext( pos );
			pItemPlus->SetUnitsubsetToNegative( strUnitsubset );
		}
		*/
		pos = m_UnitTemplateList.GetHeadPosition();
		while( pos )
		{
			CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
			pUnitTemplate->GetAllowUnitsubsetObj()->SetUnitsubsetToNegative( strUnitsubset );
		}

		/*
		pos = m_Allow_BuildingList.GetHeadPosition();
		while( pos )
		{
			CItemAndUnitsubset* pItemPlus = m_Allow_BuildingList.GetNext( pos );
			pItemPlus->SetUnitsubsetToNegative( strUnitsubset );
		}
		*/
		pos = m_BuildingDescriptionList.GetHeadPosition();
		while( pos )
		{
			CBuildingDescription* pBuildingDesc = m_BuildingDescriptionList.GetNext( pos );
			pBuildingDesc->GetAllowUnitsubsetObj()->SetUnitsubsetToNegative( strUnitsubset );
		}
	}

	// Copy the information
	{
		// Free Units, Technology
		pos = m_InitialFreeTechnologyList.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeTechnologyList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubsetToDuplicate )
			{
				AddInitialFreeTechnology( strUnitsubset, pUnitsubsetValue->m_strValue );
			}
		}
		pos = m_InitialFreeUnitCoastalCityList.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitCoastalCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubsetToDuplicate )
			{
				AddInitialFreeUnitCoastalCity( strUnitsubset, pUnitsubsetValue->m_strValue );
			}
		}
		pos = m_InitialFreeUnitLandlockedCityList.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitLandlockedCityList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubsetToDuplicate )
			{
				AddInitialFreeUnitLandlockedCity( strUnitsubset, pUnitsubsetValue->m_strValue );
			}
		}
		// Can Build Units, Buildings
		pos = m_InitialCanBuildUnitList.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubsetToDuplicate )
			{
				AddInitialCanBuildUnit( strUnitsubset, pUnitsubsetValue->m_strValue );
			}
		}
		pos = m_InitialCanBuildBuildingList.GetHeadPosition();
		while( pos )
		{
			POSITION prevPos = pos;
			CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
			if( pUnitsubsetValue->m_strUnitsubset == strUnitsubsetToDuplicate )
			{
				AddInitialCanBuildBuilding( strUnitsubset, pUnitsubsetValue->m_strValue );
			}
		}
		// Allow Research
		/*
		pos = m_Allow_TechnologyList.GetHeadPosition();
		while( pos )
		{
			CItemAndUnitsubset* pItemPlus = m_Allow_TechnologyList.GetNext( pos );
			if( pItemPlus->UnitsubsetIsPositive( strUnitsubsetToDuplicate ) )
			{
				pItemPlus->SetUnitsubsetToPositive( strUnitsubset );
			}
		}
		*/
		pos = m_TechnologyList.GetHeadPosition();
		while( pos )
		{
			CTechnologyDesc* pTechnologyDesc = m_TechnologyList.GetNext( pos );
			if( pTechnologyDesc->GetAllowUnitsubsetObj()->UnitsubsetIsPositive( strUnitsubsetToDuplicate ) )
			{
				pTechnologyDesc->GetAllowUnitsubsetObj()->SetUnitsubsetToPositive( strUnitsubset );
			}
		}
		/*
		pos = m_Allow_UnitList.GetHeadPosition();
		while( pos )
		{
			CItemAndUnitsubset* pItemPlus = m_Allow_UnitList.GetNext( pos );
			if( pItemPlus->UnitsubsetIsPositive( strUnitsubsetToDuplicate ) )
			{
				pItemPlus->SetUnitsubsetToPositive( strUnitsubset );
			}
		}
		*/
		pos = m_UnitTemplateList.GetHeadPosition();
		while( pos )
		{
			CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
			if( pUnitTemplate->GetAllowUnitsubsetObj()->UnitsubsetIsPositive( strUnitsubsetToDuplicate ) )
			{
				pUnitTemplate->GetAllowUnitsubsetObj()->SetUnitsubsetToPositive( strUnitsubset );
			}
		}

		/*
		pos = m_Allow_BuildingList.GetHeadPosition();
		while( pos )
		{
			CItemAndUnitsubset* pItemPlus = m_Allow_BuildingList.GetNext( pos );
			if( pItemPlus->UnitsubsetIsPositive( strUnitsubsetToDuplicate ) )
			{
				pItemPlus->SetUnitsubsetToPositive( strUnitsubset );
			}
		}
		*/
		pos = m_BuildingDescriptionList.GetHeadPosition();
		while( pos )
		{
			CBuildingDescription* pBuildingDesc = m_BuildingDescriptionList.GetNext( pos );
			if( pBuildingDesc->GetAllowUnitsubsetObj()->UnitsubsetIsPositive( strUnitsubsetToDuplicate ) )
			{
				pBuildingDesc->GetAllowUnitsubsetObj()->SetUnitsubsetToPositive( strUnitsubset );
			}
		}
	}
}

void  CUnitset::RemoveUnitsubset( CString strUnitsubset )
{
	POSITION pos = m_UnitsubsetList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CString strUnitsubsetInList = m_UnitsubsetList.GetNext( pos );
		if( strUnitsubsetInList == strUnitsubset )
		{
			m_UnitsubsetList.RemoveAt( prevPos );
		}
	}
}

long  CUnitset::GetUnitsubsetIndex( CString strUnitsubset )
{
	long iIndex = 1;
	POSITION pos = m_UnitsubsetList.GetHeadPosition();
	while( pos )
	{
		CString strUnitsubsetInList = m_UnitsubsetList.GetNext( pos );
		if( strUnitsubsetInList == strUnitsubset )
		{
			return iIndex;
		}
		iIndex++;
	}
	return 0;
}

/*
bool  CUnitset::GetResearchAllowed( CString strUnitsubset, CString strTech )
{
	bool bValue = false;
	POSITION pos = m_AllowResearchList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_AllowResearchList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strTech )
		{
			return true;
		}
	}
	return false;
}
*/

bool  CUnitset::AllUnitTemplateImagesExistLocally( CStringList* pMissingUnitTemplateImages )
{
	m_UnitTemplateImages.RemoveAll();
	POSITION pos = m_UnitTemplateList.GetHeadPosition();
	while( pos )
	{
		CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
		m_UnitTemplateImages.AddTail( pUnitTemplate->GetUnitImageName() );
	}
	pos = m_UnitTemplateImages.GetHeadPosition();
	while( pos )
	{
		CString strUnitTemplateImage = m_UnitTemplateImages.GetNext( pos );
		if( CUnitTemplateImage::UnitTemplateImageFileExists( strUnitTemplateImage ) == false )
		{
			pMissingUnitTemplateImages->AddTail( strUnitTemplateImage );
		}
	}
	if( pMissingUnitTemplateImages->IsEmpty() )
	{
		return true;
	}
	return false;
}

void  CUnitset::UpdatePlayerProxyInformation()
{
	POSITION pos = m_InitialFreeTechnologyList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeTechnologyList.GetNext( pos );

		CTechnologyDesc* pTechNode = GetTechnologyDesc( pUnitsubsetValue->m_strValue );
		if( pTechNode )
		{
			//pTechNode->SetHasBeenDiscovered( pUnitsubsetValue->m_strUnitsubset );
			GetCommonState()->GetWorldDescServer()->SetTechnologyHasBeenDiscovered( pUnitsubsetValue->m_strUnitsubset, pUnitsubsetValue->m_strValue );
		}
	}
}


/*
bool  CUnitset::AlreadyKnows( CString strNationName, CString strTech )
{
	bool bAlreadyKnows = false;

	// Iterate over the initial state information
	POSITION pos = m_InitialFreeTechnologyList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeTechnologyList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == "" ||
			pUnitsubsetValue->m_strUnitsubset == strNationName )
		{
			if( pUnitsubsetValue->m_strValue == strTech )
			{
				return true;
			}
		}
	}
	// Iterate over researched technologies
	pos = m_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CTechnologyNode* pTechNode = m_TechnologyList.GetNext( pos );
		if( pTechNode->GetName() == strTech )
		{
			if( pTechNode->HasBeenDiscoveredBy( strNationName ) )
			{
				return true;
			}
		}
	}
	return false;
}
*/

/*
void  CUnitset::SetToDefault()
{
	this->LoadUnitSet( "Official" );
}
*/



void  CUnitset::AddBuildOption( CBuildOption* pBuildOption )
{
	pBuildOption->SetId( m_iNextBuildOptionId );
	m_iNextBuildOptionId++;
	m_BuildOptionList.AddTail( pBuildOption );
}

CBuildOption* CUnitset::GetBuildOption( CString strBuildTarget )
{
	POSITION pos = m_BuildOptionList.GetHeadPosition();
	while( pos )
	{
		CBuildOption* pBuildOption = m_BuildOptionList.GetNext( pos );
		if( pBuildOption->GetBuildTarget() == strBuildTarget )
		{
			return pBuildOption;
		}
	}
	return NULL;
}
/*
CBuildOption* CUnitset::GetBuildOption( DWORD id )
{
	POSITION pos = m_BuildOptionList.GetHeadPosition();
	while( pos )
	{
		CBuildOption* pBuildOption = m_BuildOptionList.GetNext( pos );
		if( pBuildOption->GetId() == id )
		{
			return pBuildOption;
		}
	}
	return NULL;
}
*/
void CUnitset::AddUnitTemplate( CUnitTemplate* pUnitTemplate )
{
	// Validate the Template

	// Must Land Between Turns / Has A Range
	/*
	if( pUnitTemplate->MustLandBetweenTurns() == true )
	{
		if( pUnitTemplate->HasARange() == false )
		{
			CString strText;
			strText.Format( "Error: Unit Template [%s] is invalid. MustLandBetweenTurns = true, HasARange = false", pUnitTemplate->GetName() );
			AfxMessageBox( strText );
			return;
		}
	}
	if( pUnitTemplate->MustLandBetweenTurns() == false )
	{
		if( pUnitTemplate->HasARange() == true )
		{
			CString strText;
			strText.Format( "Error: Unit Template [%s] is invalid. MustLandBetweenTurns = false, HasARange = true", pUnitTemplate->GetName() );
			AfxMessageBox( strText );
			return;
		}
	}
	*/

	// Submarine Detection / Submarine Detection Range
	/*
	if( pUnitTemplate->GetSubmarineDetection() > 0.0f )
	{
		if( pUnitTemplate->GetSubmarineDetectionRange() == 0.0f )
		{
			CString strText;
			strText.Format( "Error: Unit Template [%s] is invalid. GetSubmarineDetection > 0.0, GetSubmarineDetectionRange = 0.0", pUnitTemplate->GetName() );
			AfxMessageBox( strText );
			return;
		}
	}
	if( pUnitTemplate->GetSubmarineDetection() == 0.0f )
	{
		if( pUnitTemplate->GetSubmarineDetectionRange() > 0.0f )
		{
			CString strText;
			strText.Format( "Error: Unit Template [%s] is invalid. GetSubmarineDetection = 0.0, GetSubmarineDetectionRange > 0.0", pUnitTemplate->GetName() );
			AfxMessageBox( strText );
			return;
		}
	}
	*/

	// Strategic Bombing / Air Units
	/*
	if( pUnitTemplate->GetStrategicBombingCapability() > 0.0f )
	{
		if( pUnitTemplate->IsAircraft() == false &&
			pUnitTemplate->IsMissile() == false )
		{
			CString strText;
			strText.Format( "Error: Unit Template [%s] is invalid. GetStrategicBombingCapability > 0.0, IsAirUnit = false", pUnitTemplate->GetExternalName() );
			AfxMessageBox( strText );
		}
	}
	*/

	// 
	m_UnitTemplateList.AddTail( pUnitTemplate );
}

CUnitTemplate*  CUnitset::GetUnitTemplate( CString strUnitName )
{
	POSITION pos = m_UnitTemplateList.GetHeadPosition();
	while( pos )
	{
		CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
		if( pUnitTemplate->GetInternalName() == strUnitName )
		{
			return pUnitTemplate;
		}
	}
	return NULL;
}

void  CUnitset::RemoveUnitTemplate( CString strName )
{
	POSITION pos = m_UnitTemplateList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
		if( pUnitTemplate->GetInternalName() == strName )
		{
			delete pUnitTemplate;
			m_UnitTemplateList.RemoveAt( prevPos );
		}
	}
	// Remove the ItemAndUnitsubset item
	/*
	pos = m_Allow_UnitList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CItemAndUnitsubset* pItemPlus = m_Allow_UnitList.GetNext( pos );
		if( pItemPlus->m_strItemName == strName )
		{
			delete pItemPlus;
			m_Allow_UnitList.RemoveAt( prevPos );
		}
	}
	*/
}

CString  CUnitset::GetExternalUnitTemplateName( CString strInternalName )
{
	CUnitTemplate* pUnitTemplate = GetUnitTemplate( strInternalName );
	if( pUnitTemplate )
	{
		pUnitTemplate->GetExternalName();
	}
	return _T("");
}

CString  CUnitset::GetExternalTechnologyName( CString strInternalName )
{
	CTechnologyDesc* pTechnologyDesc = this->GetTechnologyDesc( strInternalName );
	if( pTechnologyDesc )
	{
		pTechnologyDesc->GetExternalName();
	}
	return _T("");
}

CString  CUnitset::GetExternalCityImprovementName( CString strInternalName )
{
	CBuildingDescription* pBuilding = GetBuildingDescription( strInternalName );
	if( pBuilding )
	{
		pBuilding->GetExternalName();
	}
	return _T("");
}

CString  CUnitset::GetExternalAirfieldImprovementName( CString strInternalName )
{
	CAirfieldImprovement* pAirfieldImprovement = GetAirfieldImprovement( strInternalName );
	if( pAirfieldImprovement )
	{
		pAirfieldImprovement->GetExternalName();
	}
	return _T("");
}

CUnitCategory*  CUnitset::GetUnitCategory( CString strCategory )
{
	POSITION pos = m_UnitCategories.GetHeadPosition();
	while( pos )
	{
		CUnitCategory* pUnitCategory = m_UnitCategories.GetNext( pos );
		if( pUnitCategory->m_strCategory == strCategory )
		{
			return pUnitCategory;
		}
	}
	return NULL;
}

void  CUnitset::InvokeUnitCategory( CString strCategory, bool bAddToFieldOrders )
{
	POSITION pos = m_UnitCategories.GetHeadPosition();
	while( pos )
	{
		CUnitCategory* pUnitCategory = m_UnitCategories.GetNext( pos );
		if( pUnitCategory->m_strCategory == strCategory )
		{
			pUnitCategory->m_bShowInFieldOrders = bAddToFieldOrders;
			return;
		}
	}
	CUnitCategory* pUnitCategory = new CUnitCategory();
	pUnitCategory->m_strCategory = strCategory;
	pUnitCategory->m_bShowInFieldOrders = bAddToFieldOrders;
	m_UnitCategories.AddTail( pUnitCategory );
}

void  CUnitset::RemoveUnitCategory( CString strCategory )
{
	POSITION pos = m_UnitCategories.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CUnitCategory* pUnitCategory = m_UnitCategories.GetNext( pos );
		if( pUnitCategory->m_strCategory == strCategory )
		{
			m_UnitCategories.RemoveAt( prevPos );
			delete pUnitCategory;
		}
	}
}


float CUnitset::GetAttritionBalance( CUnitTemplate* pUnitTemplate, CUnitTemplate* pOtherUnitTemplate )
{
	float fAttrition1 = GetAttritionVs( pUnitTemplate, pOtherUnitTemplate );
	float fAttrition2 = GetAttritionVs( pOtherUnitTemplate, pUnitTemplate );

	float fPercent = 0.0f;
	if( fAttrition1 == 0.0f && fAttrition2 == 0.0f )
	{
		fPercent = 0.0f;
		//strText = "-";
		//pButton2->AddTextString( strText, iPosX+25-CBCButton::GetTextWidth( strText ),13 );
	}
	else if( fAttrition1 == 0.0f && fAttrition2 > 0.0f )
	{
		fPercent = 0.0f;
		//strText = "-";
		//pButton2->AddTextString( strText, iPosX+28-CBCButton::GetTextWidth( strText ),13 );
	}
	else if( fAttrition1 > 0.0f && fAttrition2 == 0.0f )
	{
		fPercent = 100.0f;
		//strText = "+";
		//pButton2->AddTextString( strText, iPosX+28-CBCButton::GetTextWidth( strText ),13 );
	}
	else if( fAttrition1 > 0.0f && fAttrition2 > 0.0f )
	{
		fPercent = fAttrition1 / fAttrition2;
		//strText.Format( "%0.2f", fPercent );
		//pButton2->AddTextString( strText, iPosX+28-CBCButton::GetTextWidth( strText ),13 );
	}
	return fPercent;
}

float CUnitset::GetAttritionVs( CUnitTemplate* pUnitTemplate, CUnitTemplate* pOtherUnitTemplate )
{
	//
	CUnitAndCombatState Unit1State( pUnitTemplate );
	CUnitAndCombatState Unit2State( pOtherUnitTemplate );
	//if( m_bUnitXEntrenched ) Unit1State.m_bEntrenched = true;
	//if( m_bUnitXDockedOrLanded ) Unit1State.m_bDockedOrLanded = true;
	//Unit1State.m_iTerrain = this->m_iUnitXTerrain;
	//if( m_bUnitsEntrenched ) Unit2State.m_bEntrenched = true;
	//if( m_bUnitsDockedOrLanded ) Unit2State.m_bDockedOrLanded = true;
	//Unit2State.m_iTerrain = m_iUnitsTerrain;
	//
	CAttritionBalanceResult  BalanceResult;
	//CCombatManager::GetAttritionBalance( Unit2State,Unit1State, bHandleRangedCombat, &BalanceResult );
	CCombatManager::GetAttritionBalance( Unit1State,Unit2State, true, &BalanceResult );
	//float fTime = BalanceResult.m_fExpectedTimeToDestroyUnit2;
	//CString strAttrition = CBCString::FloatAsString_2SignificantDigits( BalanceResult.m_fAttritionBalance );
	return BalanceResult.m_fAttritionBalance;

	/*
	CString strOtherCombatUnitType = pOtherUnitTemplate->GetCombatUnitTypeString();

	CAttackVs* pAttackVs = pUnitTemplate->GetAttackVs( strOtherCombatUnitType );
	if( pAttackVs && 
		pAttackVs->CanTarget() &&
		pAttackVs->GetAlwaysHits() == false )
	{
		if( pUnitTemplate->GetProductionCost() > 0 )
		{
			float fAttrition =
				( pAttackVs->GetToHit() *
				  pAttackVs->GetDamage() *
				  pUnitTemplate->GetMaxHP() *
				  pUnitTemplate->GetDefenseBase() ) /
				( pUnitTemplate->GetProductionCost() + pUnitTemplate->GetIronCost() );
			return fAttrition;
		}
	}
	*/
	return 0.0f;
}

float CUnitset::GetAttackRange( CUnitTemplate* pUnitTemplate, CUnitTemplate* pOtherUnitTemplate )
{
	//CString strOtherCombatUnitType = pOtherUnitTemplate->GetCombatUnitTypeString();
	long iOtherCombatUnitType = pOtherUnitTemplate->GetCombatUnitTypeLong();

	//CAttackVs* pAttackVs = pUnitTemplate->GetAttackVs( strOtherCombatUnitType );
	CAttackVs* pAttackVs = pUnitTemplate->GetAttackVsCombatUnitType( iOtherCombatUnitType );
	if( pAttackVs && pAttackVs->CanTarget() )
	{
		if( pAttackVs->GetAttackRangeIsDirectlyOverTarget() ) return 0.0f;
		return pAttackVs->GetAttackRange();
	}
	return 0.0f;
}

void  CUnitset::GetUnitTemplates( CString strInTag, CList< CUnitTemplate* >* pOutUnitTemplateList )
{
	POSITION pos = m_UnitTemplateList.GetHeadPosition();
	while( pos )
	{
		CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
		if( pUnitTemplate->UnitTagExists( strInTag ) )
		{
			pOutUnitTemplateList->AddTail( pUnitTemplate );
		}
	}
}


/*
CBuildingDescription*  CUnitset::LoadBuildingDescription( CString strShortFilename )
{
	CString strFullPathToBuildingDirectory = g_pApp->GetBaseDirectory() + "\\Data\\Unitsets\\" + m_strLocalFile + "\\Buildings\\";
	CString strFullPathToFile = strFullPathToBuildingDirectory + strShortFilename + ".building";

	CStdioFile File;
	if( File.Open( strFullPathToFile, CFile::modeRead | CFile::typeText ) == false )
	{
		CString strText;
		strText.Format( "Could not open file %s.", strFullPathToFile );
		AfxMessageBox( strText );
		File.Close();
		return NULL;
	}

	CStringDataBlock StringDataBlock2;
	StringDataBlock2.Read( &File );
	File.Close();

	CString strReqAppVersion = StringDataBlock2.GetValue( "ApplicationVersionRequired" );
	CApplicationVersion ReqAppVersion( strReqAppVersion );
	if( ReqAppVersion > g_pApp->GetApplicationVersion() )
	{
		CString strText;
		strText.Format( "Could not read file %s.\nUpgrade to Version %s of the Application.", 
			strFullPathToBuildingDirectory, ReqAppVersion.GetBuildId() );
		AfxMessageBox( strText );
		return NULL;
	}

	CString strFileVersion = StringDataBlock2.GetValue( "FileVersion" );
	long iFileVersion = _ttol( strFileVersion );
	if( iFileVersion != 1 )
	{
		CString strText;
		strText.Format( "Could not read file %s.  Wrong FileVersion.", 
			strFullPathToBuildingDirectory );
		AfxMessageBox( strText );
		return NULL;
	}

	CBuildingDescription* pBuildingDescription = new CBuildingDescription( this );

	// Add to BuildOptionSet as a building
	//this->AddBuildingDescription( pBuildingDescription );
	m_BuildingDescriptionList.AddTail( pBuildingDescription );

	// Add to BuildOptionSet as a Build Option
	CBuildOption* pBuildOption = new CBuildOption();
	pBuildOption->SetBuildOptionSet( this );
	this->AddBuildOption( pBuildOption );

	if( iFileVersion == 1 )
	{
		CString strValue;

		pBuildingDescription->m_strInternalName = strShortFilename;

		strValue = StringDataBlock2.GetValue( "ExternalName" );
		pBuildingDescription->m_strExternalName = strValue;

		strValue = StringDataBlock2.GetValue( "ShortSummary" );
		pBuildingDescription->m_strShortSummary = strValue;

		strValue = StringDataBlock2.GetValue( "Description" );
		pBuildingDescription->m_strDescription = strValue;

		strValue = StringDataBlock2.GetValue( "Image" );
		//pBuildingDescription->m_strDescription = strValue;
		pBuildingDescription->SetImagePath( "Data\\Images\\Buildings\\" + strValue + ".png" );
		pBuildingDescription->SetWhiteImagePath( "Data\\Images\\Buildings\\" + strValue + "-c.png" );

		strValue = StringDataBlock2.GetValue( "ProductionView-PositionX" );
		pBuildingDescription->m_iPositionX = _ttol( strValue );
		strValue = StringDataBlock2.GetValue( "ProductionView-PositionY" );
		pBuildingDescription->m_iPositionY = _ttol( strValue );

		strValue = StringDataBlock2.GetValue( "Requirements", "MinimumPopulationRequired" );
		pBuildingDescription->m_fMinimumPopulationRequired = _ttol( strValue );
		strValue = StringDataBlock2.GetValue( "Requirements", "CanOnlyBeBuiltInCitiesAdjacentToWater" );
		pBuildingDescription->m_bCanOnlyBeBuiltInCitiesAdjacentToWater = ( strValue == "true" ? true : false );

		long iCount = StringDataBlock2.GetCount( "Requirements", "Technology" );
		for( long i=0; i<iCount; i++ )
		{
			CString strTechnology = StringDataBlock2.GetValue( "Requirements", "Technology", "", i );
			pBuildingDescription->GetPrereqTechList()->AddTail( strTechnology );
		}

		strValue = StringDataBlock2.GetValue( "Cost", "Production" );
		pBuildingDescription->m_iProductionCost = _ttol( strValue );
		strValue = StringDataBlock2.GetValue( "Cost", "Iron" );
		pBuildingDescription->m_iIronCost = _ttol( strValue );

		strValue = StringDataBlock2.GetValue( "Effects", "ProductionBonus" );
		pBuildingDescription->m_fProductionBonus = _tstof( strValue );
		strValue = StringDataBlock2.GetValue( "Effects", "ProductionBonusTimesPopulation" );
		pBuildingDescription->m_fProductionBonusTimesPopulation = _tstof( strValue );
		/-*
		strValue = StringDataBlock2.GetValue( "Effects", "CanRepairAircraft" );
		pBuildingDescription->m_bCanRepairAircraft = ( strValue == "true" ? true : false );
		strValue = StringDataBlock2.GetValue( "Effects", "CanRepairGroundUnits" );
		pBuildingDescription->m_bCanRepairGroundUnits = ( strValue == "true" ? true : false );
		strValue = StringDataBlock2.GetValue( "Effects", "CanRepairSeaUnits" );
		pBuildingDescription->m_bCanRepairSeaUnits = ( strValue == "true" ? true : false );
		*-/
		strValue = StringDataBlock2.GetValue( "Effects", "RepairAircraftRate" );
		pBuildingDescription->m_fRepairAircraftRate = _tstof( strValue );
		strValue = StringDataBlock2.GetValue( "Effects", "RepairGroundUnitRate" );
		pBuildingDescription->m_fRepairGroundUnitRate = _tstof( strValue );
		strValue = StringDataBlock2.GetValue( "Effects", "RepairSeaUnitRate" );
		pBuildingDescription->m_fRepairSeaUnitRate = _tstof( strValue );

		strValue = StringDataBlock2.GetValue( "Effects", "FoodProvidedToUnitsInCity" );
		pBuildingDescription->m_fFoodProvidedToUnitsInCity = _tstof( strValue );
		strValue = StringDataBlock2.GetValue( "Effects", "OilProductionUptoDouble" );
		pBuildingDescription->m_fOilProductionUptoDouble = _tstof( strValue );
	}
	pBuildOption->SetBuildTargetToBuilding( pBuildingDescription );

	return pBuildingDescription;
}
*/

/*
void  CUnitset::AddBuildingDescription( CBuildingDescription* pBuildingDescription )
{
	m_BuildingDescriptionList.AddTail( pBuildingDescription );
}
*/
/*
CBuildingDescription* CUnitset::GetBuildingDescriptionThatUpgradesTo( CString strInternalName )
{
	POSITION pos = m_BuildingDescriptionList.GetHeadPosition();
	while( pos )
	{
		CBuildingDescription* pBuilding = m_BuildingDescriptionList.GetNext( pos );
		if( pBuilding->m_strUpgradesTo == strInternalName )
		{
			return pBuilding;
		}
	}
	return NULL;
}
*/
CBuildingDescription* CUnitset::GetBuildingDescription( CString strInternalName )
{
	POSITION pos = m_BuildingDescriptionList.GetHeadPosition();
	while( pos )
	{
		CBuildingDescription* pBuilding = m_BuildingDescriptionList.GetNext( pos );
		if( pBuilding->GetInternalName() == strInternalName )
		{
			return pBuilding;
		}
	}
	return NULL;
}

void  CUnitset::DeleteBuildingDescription( CString strInternalName )
{
	POSITION pos = m_BuildingDescriptionList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CBuildingDescription* pBuilding = m_BuildingDescriptionList.GetNext( pos );
		if( pBuilding->GetInternalName() == strInternalName )
		{
			m_BuildingDescriptionList.RemoveAt( prevPos );
			delete pBuilding;
		}
	}
}

CBuildingDescription* CUnitset::GetBuildingDescriptionFromUpgradeLineAndLevel( CString strUpgradeLine, long iUpgradeLevel )
{
	POSITION pos = m_BuildingDescriptionList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CBuildingDescription* pBuilding = m_BuildingDescriptionList.GetNext( pos );
		if( pBuilding->m_strUpgradeLine == strUpgradeLine &&
			pBuilding->m_iUpgradeLevel == iUpgradeLevel )
		{
			return pBuilding;
		}
	}
	return NULL;
}


CAirfieldImprovement* CUnitset::GetAirfieldImprovement( CString strInternalName )
{
	POSITION pos = m_AirfieldImprovementList.GetHeadPosition();
	while( pos )
	{
		CAirfieldImprovement* pImprovement = m_AirfieldImprovementList.GetNext( pos );
		if( pImprovement->GetInternalName() == strInternalName )
		{
			return pImprovement;
		}
	}
	return NULL;
}

void  CUnitset::DeleteAirfieldImprovement( CString strInternalName )
{
	POSITION pos = m_AirfieldImprovementList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CAirfieldImprovement* pImprovement = m_AirfieldImprovementList.GetNext( pos );
		if( pImprovement->GetInternalName() == strInternalName )
		{
			m_AirfieldImprovementList.RemoveAt( prevPos );
			delete pImprovement;
		}
	}
}
/*
CMovementUnitType*  CUnitset::GetMovementUnitType( CString strName )
{
	POSITION pos = m_MovementUnitTypes.GetHeadPosition();
	while( pos )
	{
		CMovementUnitType* pMovementUnitType = m_MovementUnitTypes.GetNext( pos );
		if( pMovementUnitType->m_strName == strName ) return pMovementUnitType;
	}
	return NULL;
}
*/

void CUnitset::AddMovementUnitType( CMovementUnitType* pMovementUnitType )
{
	// If the m_iMovementUnitType is 0, then assign a unique number
	if( pMovementUnitType->m_iMovementUnitType == 0 )
	{
		long iHighestMovementUnitType = 0;
		POSITION pos = m_MovementUnitTypes.GetHeadPosition();
		while( pos )
		{
			CMovementUnitType* pMovementUnitTypeInList = m_MovementUnitTypes.GetNext( pos );
			iHighestMovementUnitType = max( iHighestMovementUnitType, pMovementUnitTypeInList->m_iMovementUnitType );
		}
		pMovementUnitType->m_iMovementUnitType = iHighestMovementUnitType+1;
	}

	m_MovementUnitTypes.AddTail( pMovementUnitType );
}

CMovementUnitType* CUnitset::GetMovementUnitType( long iMovementUnitType )
{
	POSITION pos = m_MovementUnitTypes.GetHeadPosition();
	while( pos )
	{
		CMovementUnitType* pMovementUnitType = m_MovementUnitTypes.GetNext( pos );
		if( pMovementUnitType->m_iMovementUnitType == iMovementUnitType ) return pMovementUnitType;
	}
	return NULL;
}

CMovementUnitType*  CUnitset::GetMovementUnitTypeByExternalName( CString strExternalName )
{
	POSITION pos = m_MovementUnitTypes.GetHeadPosition();
	while( pos )
	{
		CMovementUnitType* pMovementUnitType = m_MovementUnitTypes.GetNext( pos );
		if( pMovementUnitType->m_strExternalName == strExternalName ) return pMovementUnitType;
	}
	return NULL;
}
		
void  CUnitset::RemoveMovementUnitType( long iMovementUnitType )
{
	POSITION pos = m_MovementUnitTypes.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CMovementUnitType* pMovementUnitType = m_MovementUnitTypes.GetNext( pos );
		if( pMovementUnitType->m_iMovementUnitType == iMovementUnitType )
		{
			delete pMovementUnitType;
			m_MovementUnitTypes.RemoveAt( prevPos );
		}
	}
}
/*
void  CUnitset::RemoveMovementUnitType( CString strMovementUnitType )
{
	POSITION pos = m_MovementUnitTypes.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CMovementUnitType* pMovementUnitType = m_MovementUnitTypes.GetNext( pos );
		if( pMovementUnitType->m_strName == strMovementUnitType )
		{
			delete pMovementUnitType;
			m_MovementUnitTypes.RemoveAt( prevPos );
		}
	}
}
*/

void CUnitset::AddCombatUnitType( CCombatUnitType* pCombatUnitType )
{
	// If the m_iMovementUnitType is 0, then assign a unique number
	if( pCombatUnitType->m_iCombatUnitType == 0 )
	{
		long iHighestCombatUnitType = 0;
		POSITION pos = m_CombatUnitTypes.GetHeadPosition();
		while( pos )
		{
			CCombatUnitType* pCombatUnitTypeInList = m_CombatUnitTypes.GetNext( pos );
			iHighestCombatUnitType = max( iHighestCombatUnitType, pCombatUnitTypeInList->m_iCombatUnitType );
		}
		pCombatUnitType->m_iCombatUnitType = iHighestCombatUnitType+1;
	}

	m_CombatUnitTypes.AddTail( pCombatUnitType );
}

CCombatUnitType* CUnitset::GetCombatUnitType( long iCombatUnitType )
{
	POSITION pos = m_CombatUnitTypes.GetHeadPosition();
	while( pos )
	{
		CCombatUnitType* pCombatUnitType = m_CombatUnitTypes.GetNext( pos );
		if( pCombatUnitType->m_iCombatUnitType == iCombatUnitType ) return pCombatUnitType;
	}
	return NULL;
}

CCombatUnitType*  CUnitset::GetCombatUnitTypeByExternalName( CString strExternalName )
{
	POSITION pos = m_CombatUnitTypes.GetHeadPosition();
	while( pos )
	{
		CCombatUnitType* pCombatUnitType = m_CombatUnitTypes.GetNext( pos );
		if( pCombatUnitType->m_strExternalName == strExternalName ) return pCombatUnitType;
	}
	return NULL;
}

void  CUnitset::RemoveCombatUnitType( long iCombatUnitType )
{
	POSITION pos = m_CombatUnitTypes.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CCombatUnitType* pCombatUnitType = m_CombatUnitTypes.GetNext( pos );
		if( pCombatUnitType->m_iCombatUnitType == iCombatUnitType )
		{
			delete pCombatUnitType;
			m_CombatUnitTypes.RemoveAt( prevPos );
		}
	}
}

void  CUnitset::RemoveCombatUnitTypeByExternalName( CString strExternalName )
{
	POSITION pos = m_CombatUnitTypes.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CCombatUnitType* pCombatUnitType = m_CombatUnitTypes.GetNext( pos );
		if( pCombatUnitType->m_strExternalName == strExternalName )
		{
			delete pCombatUnitType;
			m_CombatUnitTypes.RemoveAt( prevPos );
		}
	}
}

void  CUnitset::AddInitialMilitiaUnit( CString strUnit )
{
	m_InitialMilitiaUnitList.AddTail( strUnit );
}

void  CUnitset::RemoveMilitiaUnit( CString strUnit )
{
	POSITION pos = m_InitialMilitiaUnitList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CString strInList = m_InitialMilitiaUnitList.GetNext( pos );
		if( strUnit == strInList )
		{
			m_InitialMilitiaUnitList.RemoveAt( prevPos );
			return;
		}
	}
}

//

void  CUnitset::AddInitialCanBuildAllUnits( CString strUnitsubset )
{
	POSITION pos = m_UnitTemplateList.GetHeadPosition();
	while( pos )
	{
		CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
		AddInitialCanBuildUnit( strUnitsubset, pUnitTemplate->GetInternalName() );
	}
}

void  CUnitset::AddInitialCanBuildUnit( CString strUnitsubset, CString strUnit )
{
	POSITION pos = m_InitialCanBuildUnitList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strUnit )
		{
			return; // it already exists
		}
	}
	CUnitsubsetValue* pUnitsubsetValue = new CUnitsubsetValue();
	pUnitsubsetValue->m_strUnitsubset = strUnitsubset;
	pUnitsubsetValue->m_strValue = strUnit;
	m_InitialCanBuildUnitList.AddTail( pUnitsubsetValue );
}

bool  CUnitset::GetInitialCanBuildUnit( CString strUnitsubset, CString strUnit )
{
	POSITION pos = m_InitialCanBuildUnitList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
		if( pUnitsubsetValue->m_strValue == strUnit &&
			pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
		{
			return true;
		}
	}
	return false;
}

void  CUnitset::RemoveInitialCanBuildUnit( CString strUnitsubset, CString strUnit )
{
	POSITION pos = m_InitialCanBuildUnitList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildUnitList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strUnit )
		{
			m_InitialCanBuildUnitList.RemoveAt( prevPos );
			delete pUnitsubsetValue;
		}
	}
}

//

void  CUnitset::AddInitialCanBuildAllBuildings( CString strUnitsubset )
{
	POSITION pos = m_BuildingDescriptionList.GetHeadPosition();
	while( pos )
	{
		CBuildingDescription* pBuildingDescription = m_BuildingDescriptionList.GetNext( pos );
		AddInitialCanBuildBuilding( strUnitsubset, pBuildingDescription->GetInternalName() );
	}
}

void  CUnitset::AddInitialCanBuildBuilding( CString strUnitsubset, CString strBuilding )
{
	POSITION pos = m_InitialCanBuildBuildingList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strBuilding )
		{
			return; // it already exists
		}
	}
	CUnitsubsetValue* pUnitsubsetValue = new CUnitsubsetValue();
	pUnitsubsetValue->m_strUnitsubset = strUnitsubset;
	pUnitsubsetValue->m_strValue = strBuilding;
	m_InitialCanBuildBuildingList.AddTail( pUnitsubsetValue );
}

bool  CUnitset::GetInitialCanBuildBuilding( CString strUnitsubset, CString strBuilding )
{
	POSITION pos = m_InitialCanBuildBuildingList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
		if( pUnitsubsetValue->m_strValue == strBuilding &&
			pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
		{
			return true;
		}
	}
	return false;
}

void  CUnitset::RemoveInitialCanBuildBuilding( CString strUnitsubset, CString strBuilding )
{
	POSITION pos = m_InitialCanBuildBuildingList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildBuildingList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strBuilding )
		{
			m_InitialCanBuildBuildingList.RemoveAt( prevPos );
			delete pUnitsubsetValue;
		}
	}
}

/////////////////////////

void  CUnitset::AddInitialCanBuildAllAirfieldImprovements( CString strUnitsubset )
{
	POSITION pos = m_AirfieldImprovementList.GetHeadPosition();
	while( pos )
	{
		CAirfieldImprovement* pAirfieldImprovement = m_AirfieldImprovementList.GetNext( pos );
		AddInitialCanBuildAirfieldImprovement( strUnitsubset, pAirfieldImprovement->GetInternalName() );
	}
}

void  CUnitset::AddInitialCanBuildAirfieldImprovement( CString strUnitsubset, CString strAirfieldImprovement )
{
	POSITION pos = m_InitialCanBuildAirfieldImprovementList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildAirfieldImprovementList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strAirfieldImprovement )
		{
			return; // it already exists
		}
	}
	CUnitsubsetValue* pUnitsubsetValue = new CUnitsubsetValue();
	pUnitsubsetValue->m_strUnitsubset = strUnitsubset;
	pUnitsubsetValue->m_strValue = strAirfieldImprovement;
	m_InitialCanBuildAirfieldImprovementList.AddTail( pUnitsubsetValue );
}

bool  CUnitset::GetInitialCanBuildAirfieldImprovement( CString strUnitsubset, CString strAirfieldImprovement )
{
	POSITION pos = m_InitialCanBuildAirfieldImprovementList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildAirfieldImprovementList.GetNext( pos );
		if( pUnitsubsetValue->m_strValue == strAirfieldImprovement &&
			pUnitsubsetValue->m_strUnitsubset == strUnitsubset )
		{
			return true;
		}
	}
	return false;
}

void  CUnitset::RemoveInitialCanBuildAirfieldImprovement( CString strUnitsubset, CString strAirfieldImprovement )
{
	POSITION pos = m_InitialCanBuildAirfieldImprovementList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CUnitsubsetValue* pUnitsubsetValue = m_InitialCanBuildAirfieldImprovementList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strAirfieldImprovement )
		{
			m_InitialCanBuildAirfieldImprovementList.RemoveAt( prevPos );
			delete pUnitsubsetValue;
		}
	}
}


/*
void  CUnitset::AddInitialState_CanBuildAllBuildings( CString strUnitsubset )
{
	CUnitsubsetValue* pUnitsubsetValue = new CUnitsubsetValue();
	pUnitsubsetValue->m_strUnitsubset = strUnitsubset;
	pUnitsubsetValue->m_strValue = "";
	m_InitialCanBuildBuildingList.AddTail( pUnitsubsetValue );
}

void  CUnitset::AddInitialState_CanBuildBuilding( CString strUnitsubset, CString strBuilding )
{
	CUnitsubsetValue* pUnitsubsetValue = new CUnitsubsetValue();
	pUnitsubsetValue->m_strUnitsubset = strUnitsubset;
	pUnitsubsetValue->m_strValue = strBuilding;
	m_InitialCanBuildBuildingList.AddTail( pUnitsubsetValue );
}
*/

// Initial Resources
//
void  CUnitset::SetUnitsubsetInitialResourceValue( CString strUnitsubset, CString strResource, long iValue )
{
	POSITION pos = m_InitialResources.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetStringLongValue* p = m_InitialResources.GetNext( pos );
		if( p->m_strUnitsubset == strUnitsubset &&
			p->m_strValue == strResource )
		{
			p->m_iValue = iValue;
			return;
		}
	}
	CUnitsubsetStringLongValue* p = new CUnitsubsetStringLongValue();
	p->m_strUnitsubset = strUnitsubset;
	p->m_strValue = strResource;
	p->m_iValue = iValue;
	m_InitialResources.AddTail( p );
}

long  CUnitset::GetUnitsubsetInitialResourceValue( CString strUnitsubset, CString strResource )
{
	POSITION pos = m_InitialResources.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetStringLongValue* p = m_InitialResources.GetNext( pos );
		if( p->m_strUnitsubset == strUnitsubset &&
			p->m_strValue == strResource )
		{
			return p->m_iValue;
		}
	}
	ASSERT( false );
	return -1;
}

void  CUnitset::AddInitialFreeTechnology( CString strUnitsubset, CString strTech )
{
	// Can't duplicate Unitsubset/Tech information
	POSITION pos = m_InitialFreeTechnologyList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeTechnologyList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strTech )
		{
			return;
		}
	}

	CUnitsubsetValue* pUnitsubsetValue = new CUnitsubsetValue();
	pUnitsubsetValue->m_strUnitsubset = strUnitsubset;
	pUnitsubsetValue->m_strValue = strTech;
	m_InitialFreeTechnologyList.AddTail( pUnitsubsetValue );
}

void  CUnitset::RemoveFreeTech( CString strUnitsubset, CString strTech )
{
	POSITION pos = m_InitialFreeTechnologyList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeTechnologyList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strTech )
		{
			delete pUnitsubsetValue;
			m_InitialFreeTechnologyList.RemoveAt( prevPos );
			return;
		}
	}
}

void  CUnitset::AddInitialFreeUnitCoastalCity( CString strUnitsubset, CString strUnit )
{
	CUnitsubsetValue* pObj = new CUnitsubsetValue();
	pObj->m_strUnitsubset = strUnitsubset;
	pObj->m_strValue = strUnit;
	m_InitialFreeUnitCoastalCityList.AddTail( pObj );
}

void  CUnitset::RemoveFreeUnitCoastalCity( CString strUnitsubset, CString strUnit )
{
	POSITION pos = m_InitialFreeUnitCoastalCityList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitCoastalCityList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strUnit )
		{
			delete pUnitsubsetValue;
			m_InitialFreeUnitCoastalCityList.RemoveAt( prevPos );
			return;
		}
	}
}

void  CUnitset::AddInitialFreeUnitLandlockedCity( CString strUnitsubset, CString strUnit )
{
	CUnitsubsetValue* pObj = new CUnitsubsetValue();
	pObj->m_strUnitsubset = strUnitsubset;
	pObj->m_strValue = strUnit;
	m_InitialFreeUnitLandlockedCityList.AddTail( pObj );
}

void  CUnitset::RemoveFreeUnitLandlockedCity( CString strUnitsubset, CString strUnit )
{
	POSITION pos = m_InitialFreeUnitLandlockedCityList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CUnitsubsetValue* pUnitsubsetValue = m_InitialFreeUnitLandlockedCityList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strUnit )
		{
			delete pUnitsubsetValue;
			m_InitialFreeUnitLandlockedCityList.RemoveAt( prevPos );
			return;
		}
	}
}

//
/*
void  CUnitset::AddAllowAllResearch( CString strUnitsubset )
{
	POSITION pos = m_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CTechnologyDesc* pTechnologyDesc = m_TechnologyList.GetNext( pos );
		AddAllowResearch( strUnitsubset, pTechnologyDesc->GetName() );
	}
}
*/
/*
void  CUnitset::AddAllowResearch( CString strUnitsubset, CString strTech )
{
	POSITION pos = m_AllowResearchList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_AllowResearchList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strTech )
		{
			return; // it already exists
		}
	}
	CUnitsubsetValue* pUnitsubsetValue = new CUnitsubsetValue();
	pUnitsubsetValue->m_strUnitsubset = strUnitsubset;
	pUnitsubsetValue->m_strValue = strTech;
	m_AllowResearchList.AddTail( pUnitsubsetValue );
}
*/
bool  CUnitset::NoUnitsubsetsCanResearchThisTechnology( CString strTech )
{
	// Check the new object
	CUnitsubsetPermission* pItemPlus = GetAllowTechnologyObj( strTech );
	if( pItemPlus )
	{
		return pItemPlus->GetNumberOfPositiveUnitsubsets() == 0;
	}
	ASSERT( false );
	return false;
}

bool  CUnitset::GetAllUnitsubsetsCanResearchThisTechnology( CString strTech )
{
	CUnitsubsetPermission* pItem = GetAllowTechnologyObj( strTech );
	if( pItem )
	{
		return pItem->AllUnitsubsetsArePositive();
	}
	return false;
}

/*
bool  CUnitset::GetAllowResearch( CString strUnitsubset, CString strTech )
{
	POSITION pos = m_AllowResearchList.GetHeadPosition();
	while( pos )
	{
		CUnitsubsetValue* pUnitsubsetValue = m_AllowResearchList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strTech )
		{
			return true; // it exists
		}
	}
	return false;
}

void  CUnitset::RemoveAllowResearch( CString strUnitsubset, CString strTech )
{
	POSITION pos = m_AllowResearchList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CUnitsubsetValue* pUnitsubsetValue = m_AllowResearchList.GetNext( pos );
		if( pUnitsubsetValue->m_strUnitsubset == strUnitsubset &&
			pUnitsubsetValue->m_strValue == strTech )
		{
			m_AllowResearchList.RemoveAt( prevPos );
			delete pUnitsubsetValue;
		}
	}
}
*/

CUnitsubsetPermission*  CUnitset::GetAllowTechnologyObj( CString strTech )
{
	POSITION pos = m_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CTechnologyDesc* pTechDesc = m_TechnologyList.GetNext( pos );
		if( pTechDesc->GetInternalName() == strTech ){ return pTechDesc->GetAllowUnitsubsetObj(); }
	}
	return NULL;
	/*
	POSITION pos = m_Allow_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CItemAndUnitsubset* pItemPlus = m_Allow_TechnologyList.GetNext( pos );
		if( pItemPlus->m_strItemName == strTech ){ return pItemPlus; }
	}
	return NULL;
	*/
}
/*
CItemAndUnitsubset*  CUnitset::GetAllowTechnologyObj_old( CString strTech )
{
	POSITION pos = m_Allow_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CItemAndUnitsubset* pItemPlus = m_Allow_TechnologyList.GetNext( pos );
		if( pItemPlus->m_strItemName == strTech ){ return pItemPlus; }
	}
	return NULL;
}
*/
/*
CItemAndUnitsubset*  CUnitset::InvokeAllowTechnologyObj( CString strTech )
{
	CItemAndUnitsubset* pItemPlus = GetAllowTechnologyObj( strTech );
	if( pItemPlus ){ return pItemPlus; }

	pItemPlus = new CItemAndUnitsubset( this );
	pItemPlus->m_strItemName = strTech;
	m_Allow_TechnologyList.AddTail( pItemPlus );
	return pItemPlus;
}
*/
void  CUnitset::AddAllowTechnology( CString strUnitsubset, CString strTech )
{
	POSITION pos = m_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CTechnologyDesc* pTechDesc = m_TechnologyList.GetNext( pos );
		if( pTechDesc->GetInternalName() == strTech )
		{
			pTechDesc->GetAllowUnitsubsetObj()->SetUnitsubsetToPositive( strUnitsubset );
		}
	}
	/*
	CItemAndUnitsubset*  pItemPlus = InvokeAllowTechnologyObj( strTech );
	pItemPlus->SetUnitsubsetToPositive( strUnitsubset );
	*/
}

void  CUnitset::RemoveAllowTechnology( CString strUnitsubset, CString strTech )
{
	POSITION pos = m_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CTechnologyDesc* pTechDesc = m_TechnologyList.GetNext( pos );
		if( pTechDesc->GetInternalName() == strTech )
		{
			pTechDesc->GetAllowUnitsubsetObj()->SetUnitsubsetToNegative( strUnitsubset );
		}
	}
	/*
	CItemAndUnitsubset* pItemPlus = InvokeAllowTechnologyObj( strTech );
	if( pItemPlus )
	{
		pItemPlus->SetUnitsubsetToNegative( strUnitsubset );
	}
	*/
}

bool  CUnitset::GetAllowTechnology( CString strUnitsubset, CString strTech )
{
	POSITION pos = m_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CTechnologyDesc* pTechDesc = m_TechnologyList.GetNext( pos );
		if( pTechDesc->GetInternalName() == strTech )
		{
			return pTechDesc->GetAllowUnitsubsetObj()->UnitsubsetIsPositive( strUnitsubset );
		}
	}
	return false;
/*
	CItemAndUnitsubset* pItemPlus = GetAllowTechnologyObj( strTech );
	if( pItemPlus )
	{
		return pItemPlus->UnitsubsetIsPositive( strUnitsubset );
	}
	return false;
*/
}

CString  CUnitset::GetAllowTechnology_UnitsubsetsString( CString strTech )
{
	CUnitsubsetPermission* pItemPlus = GetAllowTechnologyObj( strTech );
	if( pItemPlus )
	{
		if( pItemPlus->AllUnitsubsetsArePositive() ){ return Lang( 1523, _T("( All )") ); }
		if( pItemPlus->GetNumberOfPositiveUnitsubsets() == 0 ){ return Lang( 366, _T("( None )") ); }

		CString strUnitsubsets;
		POSITION pos = GetUnitsubsetList()->GetHeadPosition();
		while( pos )
		{
			CString strUnitsubset = GetUnitsubsetList()->GetNext( pos );
			if( pItemPlus->ExistsInList( strUnitsubset ) )
			{
				if( strUnitsubsets != _T("") ){ strUnitsubsets += _T(", "); }
				strUnitsubsets += strUnitsubset;
			}
		}
		if( pItemPlus->m_bListContainsPositiveItems == false ){ CString str; str.Format( Lang( 1524, _T("All except %s") ), strUnitsubsets ); return str; } //"All except " + strUnitsubsets; }
		return strUnitsubsets;
	}
	ASSERT( false );
	return _T("");
}

///////////////////

CUnitsubsetPermission*  CUnitset::GetAllowUnitObj( CString strUnit )
{
	POSITION pos = m_UnitTemplateList.GetHeadPosition();
	while( pos )
	{
		CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
		if( pUnitTemplate->GetInternalName() == strUnit )
		{
			return pUnitTemplate->GetAllowUnitsubsetObj();
		}
	}
	return NULL;
}
/*
CItemAndUnitsubset*  CUnitset::GetAllowUnitObj_old( CString strUnit )
{
	POSITION pos = m_Allow_UnitList.GetHeadPosition();
	while( pos )
	{
		CItemAndUnitsubset* pItemPlus = m_Allow_UnitList.GetNext( pos );
		if( pItemPlus->m_strItemName == strUnit ){ return pItemPlus; }
	}
	return NULL;
}
*/
/*
CItemAndUnitsubset*  CUnitset::InvokeAllowUnitObj( CString strUnit )
{
	CItemAndUnitsubset* pItemPlus = GetAllowUnitObj( strUnit );
	if( pItemPlus ){ return pItemPlus; }

	pItemPlus = new CItemAndUnitsubset( this );
	pItemPlus->m_strItemName = strUnit;
	m_Allow_UnitList.AddTail( pItemPlus );
	return pItemPlus;
}
*/
void  CUnitset::AddAllowUnit( CString strUnitsubset, CString strUnit )
{
	/*
	CItemAndUnitsubset*  pItemPlus = InvokeAllowUnitObj( strUnit );
	pItemPlus->SetUnitsubsetToPositive( strUnitsubset );
	*/
	POSITION pos = m_UnitTemplateList.GetHeadPosition();
	while( pos )
	{
		CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
		if( pUnitTemplate->GetInternalName() == strUnit )
		{
			return pUnitTemplate->GetAllowUnitsubsetObj()->SetUnitsubsetToPositive( strUnitsubset );
		}
	}
}

void  CUnitset::RemoveAllowUnit( CString strUnitsubset, CString strUnit )
{
	/*
	CItemAndUnitsubset* pItemPlus = InvokeAllowUnitObj( strUnit );
	if( pItemPlus )
	{
		pItemPlus->SetUnitsubsetToNegative( strUnitsubset );
	}
	*/
	POSITION pos = m_UnitTemplateList.GetHeadPosition();
	while( pos )
	{
		CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
		if( pUnitTemplate->GetInternalName() == strUnit )
		{
			return pUnitTemplate->GetAllowUnitsubsetObj()->SetUnitsubsetToNegative( strUnitsubset );
		}
	}
}

bool  CUnitset::GetAllowUnit( CString strUnitsubset, CString strUnit )
{
	POSITION pos = m_UnitTemplateList.GetHeadPosition();
	while( pos )
	{
		CUnitTemplate* pUnitTemplate = m_UnitTemplateList.GetNext( pos );
		if( pUnitTemplate->GetInternalName() == strUnit )
		{
			return pUnitTemplate->GetAllowUnitsubsetObj()->UnitsubsetIsPositive( strUnitsubset );
		}
	}
	/*
	CItemAndUnitsubset* pItemPlus = GetAllowUnitObj( strUnit );
	if( pItemPlus )
	{
		return pItemPlus->UnitsubsetIsPositive( strUnitsubset );
	}
	*/
	return false;
}

CString  CUnitset::GetAllowUnit_UnitsubsetsString( CString strUnit )
{
	if( strUnit == _T("") ) return _T("");

	CUnitsubsetPermission* pItemPlus = GetAllowUnitObj( strUnit );
	if( pItemPlus )
	{
		if( pItemPlus->AllUnitsubsetsArePositive() ){ return Lang( 1523, _T("( All )") ); }
		if( pItemPlus->GetNumberOfPositiveUnitsubsets() == 0 ){ return Lang( 366, _T("( None )") ); }

		CString strUnitsubsets;
		POSITION pos = GetUnitsubsetList()->GetHeadPosition();
		while( pos )
		{
			CString strUnitsubset = GetUnitsubsetList()->GetNext( pos );
			if( pItemPlus->ExistsInList( strUnitsubset ) )
			{
				if( strUnitsubsets != _T("") ){ strUnitsubsets += _T(", "); }
				strUnitsubsets += strUnitsubset;
			}
		}
		if( pItemPlus->m_bListContainsPositiveItems == false ){ CString str; str.Format( Lang( 1524, _T("All except %s") ), strUnitsubsets ); return str; } //return "All except " + strUnitsubsets; }
		return strUnitsubsets;
	}
	/*
	CItemAndUnitsubset* pItemPlus = GetAllowUnitObj( strUnit );
	if( pItemPlus )
	{
		if( pItemPlus->AllUnitsubsetsArePositive() ){ return "( All )"; }
		if( pItemPlus->GetNumberOfPositiveUnitsubsets() == 0 ){ return "( None )"; }

		CString strUnitsubsets;
		POSITION pos = GetUnitsubsetList()->GetHeadPosition();
		while( pos )
		{
			CString strUnitsubset = GetUnitsubsetList()->GetNext( pos );
			if( pItemPlus->ExistsInList( strUnitsubset ) )
			{
				if( strUnitsubsets != "" ){ strUnitsubsets += ", "; }
				strUnitsubsets += strUnitsubset;
			}
		}
		if( pItemPlus->m_bListContainsPositiveItems == false ){ return "All except " + strUnitsubsets; }
		return strUnitsubsets;
	}
	*/
	ASSERT( false );
	return _T("");
}

///////////////////

CUnitsubsetPermission*  CUnitset::GetAllowBuildingObj( CString strBuilding )
{
	POSITION pos = m_BuildingDescriptionList.GetHeadPosition();
	while( pos )
	{
		CBuildingDescription* pBuildingDesc = m_BuildingDescriptionList.GetNext( pos );
		if( pBuildingDesc->GetInternalName() == strBuilding )
		{
			return pBuildingDesc->GetAllowUnitsubsetObj();
		}
	}
	return NULL;
}

void  CUnitset::AddAllowBuilding( CString strUnitsubset, CString strBuilding )
{
	POSITION pos = m_BuildingDescriptionList.GetHeadPosition();
	while( pos )
	{
		CBuildingDescription* pBuildingDesc = m_BuildingDescriptionList.GetNext( pos );
		if( pBuildingDesc->GetInternalName() == strBuilding )
		{
			pBuildingDesc->GetAllowUnitsubsetObj()->SetUnitsubsetToPositive( strUnitsubset );
		}
	}
}

void  CUnitset::RemoveAllowBuilding( CString strUnitsubset, CString strBuilding )
{
	POSITION pos = m_BuildingDescriptionList.GetHeadPosition();
	while( pos )
	{
		CBuildingDescription* pBuildingDesc = m_BuildingDescriptionList.GetNext( pos );
		if( pBuildingDesc->GetInternalName() == strBuilding )
		{
			pBuildingDesc->GetAllowUnitsubsetObj()->SetUnitsubsetToNegative( strUnitsubset );
		}
	}
}

bool  CUnitset::GetAllowBuilding( CString strUnitsubset, CString strBuilding )
{
	POSITION pos = m_BuildingDescriptionList.GetHeadPosition();
	while( pos )
	{
		CBuildingDescription* pBuildingDesc = m_BuildingDescriptionList.GetNext( pos );
		if( pBuildingDesc->GetInternalName() == strBuilding )
		{
			return pBuildingDesc->GetAllowUnitsubsetObj()->UnitsubsetIsPositive( strUnitsubset );
		}
	}
	return false;
}

CString  CUnitset::GetAllowBuilding_UnitsubsetsString( CString strBuilding )
{
	CUnitsubsetPermission* pItemPlus = GetAllowBuildingObj( strBuilding );
	if( pItemPlus )
	{
		if( pItemPlus->AllUnitsubsetsArePositive() ){ return Lang( 1523, _T("( All )") ); }
		if( pItemPlus->GetNumberOfPositiveUnitsubsets() == 0 ){ return Lang( 366, _T("( None )") ); }

		CString strUnitsubsets;
		POSITION pos = GetUnitsubsetList()->GetHeadPosition();
		while( pos )
		{
			CString strUnitsubset = GetUnitsubsetList()->GetNext( pos );
			if( pItemPlus->ExistsInList( strUnitsubset ) )
			{
				if( strUnitsubsets != _T("") ){ strUnitsubsets += _T(", "); }
				strUnitsubsets += strUnitsubset;
			}
		}
		if( pItemPlus->m_bListContainsPositiveItems == false ){ CString str; str.Format( Lang( 1524, _T("All except %s") ), strUnitsubsets ); return str; } //return "All except " + strUnitsubsets; }
		return strUnitsubsets;
	}
	ASSERT( false );
	return _T("");
}

/////////////////

CUnitsubsetPermission*  CUnitset::GetAllowAirfieldImprovementObj( CString strAirfieldImprovement )
{
	POSITION pos = m_AirfieldImprovementList.GetHeadPosition();
	while( pos )
	{
		CAirfieldImprovement* pAirfieldImprovement = m_AirfieldImprovementList.GetNext( pos );
		if( pAirfieldImprovement->GetInternalName() == strAirfieldImprovement )
		{
			return pAirfieldImprovement->GetAllowUnitsubsetObj();
		}
	}
	return NULL;
}

void  CUnitset::AddAllowAirfieldImprovement( CString strUnitsubset, CString strAirfieldImprovement )
{
	POSITION pos = m_AirfieldImprovementList.GetHeadPosition();
	while( pos )
	{
		CAirfieldImprovement* pAirfieldImprovement = m_AirfieldImprovementList.GetNext( pos );
		if( pAirfieldImprovement->GetInternalName() == strAirfieldImprovement )
		{
			pAirfieldImprovement->GetAllowUnitsubsetObj()->SetUnitsubsetToPositive( strUnitsubset );
		}
	}
}

void  CUnitset::RemoveAllowAirfieldImprovement( CString strUnitsubset, CString strAirfieldImprovement )
{
	POSITION pos = m_AirfieldImprovementList.GetHeadPosition();
	while( pos )
	{
		CAirfieldImprovement* pAirfieldImprovement = m_AirfieldImprovementList.GetNext( pos );
		if( pAirfieldImprovement->GetInternalName() == strAirfieldImprovement )
		{
			pAirfieldImprovement->GetAllowUnitsubsetObj()->SetUnitsubsetToNegative( strUnitsubset );
		}
	}
}

bool  CUnitset::GetAllowAirfieldImprovement( CString strUnitsubset, CString strAirfieldImprovement )
{
	POSITION pos = m_AirfieldImprovementList.GetHeadPosition();
	while( pos )
	{
		CAirfieldImprovement* pAirfieldImprovement = m_AirfieldImprovementList.GetNext( pos );
		if( pAirfieldImprovement->GetInternalName() == strAirfieldImprovement )
		{
			return pAirfieldImprovement->GetAllowUnitsubsetObj()->UnitsubsetIsPositive( strUnitsubset );
		}
	}
	return false;
}

CString  CUnitset::GetAllowAirfieldImprovement_UnitsubsetsString( CString strAirfieldImprovement )
{
	CUnitsubsetPermission* pItemPlus = GetAllowAirfieldImprovementObj( strAirfieldImprovement );
	if( pItemPlus )
	{
		if( pItemPlus->AllUnitsubsetsArePositive() ){ return Lang( 1523, _T("( All )") ); }
		if( pItemPlus->GetNumberOfPositiveUnitsubsets() == 0 ){ return Lang( 366, _T("( None )") ); }

		CString strUnitsubsets;
		POSITION pos = GetUnitsubsetList()->GetHeadPosition();
		while( pos )
		{
			CString strUnitsubset = GetUnitsubsetList()->GetNext( pos );
			if( pItemPlus->ExistsInList( strUnitsubset ) )
			{
				if( strUnitsubsets != _T("") ){ strUnitsubsets += _T(", "); }
				strUnitsubsets += strUnitsubset;
			}
		}
		if( pItemPlus->m_bListContainsPositiveItems == false ){ CString str; str.Format( Lang( 1524, _T("All except %s") ), strUnitsubsets ); return str; } //return "All except " + strUnitsubsets; }
		return strUnitsubsets;
	}
	ASSERT( false );
	return _T("");
}


/*
CAnimationTemplate* CUnitset::GetAnimationByName( CString strName )
{
	POSITION pos = m_AnimationTemplateList.GetHeadPosition();
	while( pos )
	{
		CAnimationTemplate* pTemplate = m_AnimationTemplateList.GetNext( pos );
		if( pTemplate->GetName() == strName )
		{
			return pTemplate;
		}
	}
	ASSERT( false );
	return NULL;
}
*/

/*
void  CUnitset::AddInitialState_CanResearch( CString strNation, CString strTech )
{
	CUnitsubsetValue* pUnitsubsetValue = new CUnitsubsetValue();
	pUnitsubsetValue->m_strUnitsubset = strNation;
	pUnitsubsetValue->m_strValue = strTech;
	m_InitialCanResearchList.AddTail( pUnitsubsetValue );
}
*/

void  CUnitset::AddTechnologyDesc( CTechnologyDesc* pTechDesc )
{
	m_TechnologyList.AddTail( pTechDesc );
}

CTechnologyDesc*  CUnitset::GetTechnologyDesc( CString strInternalName )
{
	POSITION pos = m_TechnologyList.GetHeadPosition();
	while( pos )
	{
		CTechnologyDesc* pTechNode = m_TechnologyList.GetNext( pos );
		if( pTechNode->GetInternalName() == strInternalName ) return pTechNode;
	}
	return NULL;
}

void  CUnitset::DeleteTechnologyDesc( CTechnologyDesc* pTechDesc )
{
	POSITION pos = m_TechnologyList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CTechnologyDesc* pTechDescInList = m_TechnologyList.GetNext( pos );
		if( pTechDescInList == pTechDesc )
		{
			m_TechnologyList.RemoveAt( prevPos );
		}
	}

	// Delete TechTreeNodes that reference this TechDesc
	DeleteTechTreeNodes( pTechDesc->GetInternalName() );

	delete pTechDesc;
}

/*
void  CUnitset::AddBaseTechTreeNode( CTechTreeNode* pTechTreeNode )
{
	m_TechTreeHeadNodes.AddTail( pTechTreeNode );
}
*/

CTechTreeNode* CUnitset::GetTechTreeNode( CString strTechDesc )
{
	POSITION pos = m_TechTreeNodes.GetHeadPosition();
	while( pos )
	{
		CTechTreeNode* pTechTreeNode = m_TechTreeNodes.GetNext( pos );
		if( pTechTreeNode->m_strTechName == strTechDesc ){ return pTechTreeNode; }
	}
	return NULL;
}

void  CUnitset::DeleteTechTreeNodes( CString strTechDesc )
{
	POSITION pos = m_TechTreeNodes.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CTechTreeNode* pTechTreeNodeInList = m_TechTreeNodes.GetNext( pos );
		if( pTechTreeNodeInList->m_strTechName == strTechDesc )
		{
			m_TechTreeNodes.RemoveAt( prevPos );

			// Re-wire the TreeTechNode
			CTechTreeNode* pCurrentNode = pTechTreeNodeInList;
			CTechTreeNode* pCurrentNodeParent = pTechTreeNodeInList->m_pParentNode;

			if( pCurrentNodeParent )
			{
				pCurrentNodeParent->RemoveChild( pCurrentNode );
			}
			// Move my children to my parent
			while( pCurrentNode->m_ChildNodes.IsEmpty() == FALSE )
			{
				CTechTreeNode* pChild = pCurrentNode->m_ChildNodes.RemoveHead();
				pChild->m_pParentNode = pCurrentNodeParent;
				if( pCurrentNodeParent )
				{
					pCurrentNodeParent->m_ChildNodes.AddTail( pChild );
				}
			}
			//
			delete pCurrentNode;
		}
	}
}

void  CUnitset::RemoveFromTechTreeNodeList( CTechTreeNode* pTechTreeNode )
{
	/*
	POSITION pos = m_TechTreeHeadNodes.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CTechTreeNode* pTechTreeNodeInList = m_TechTreeHeadNodes.GetNext( pos );
		if( pTechTreeNodeInList == pTechTreeNode )
		{
			m_TechTreeHeadNodes.RemoveAt( prevPos );
		}
	}
	*/
	POSITION pos = m_TechTreeNodes.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CTechTreeNode* pTechTreeNodeInList = m_TechTreeNodes.GetNext( pos );
		if( pTechTreeNodeInList == pTechTreeNode )
		{
			m_TechTreeNodes.RemoveAt( prevPos );
		}
	}
}

CTechTreeNode*  CUnitset::GetFirstTechTreeNode( CString strTechDesc )
{
	POSITION pos = m_TechTreeNodes.GetHeadPosition();
	while( pos )
	{
		CTechTreeNode* pTechTreeNodeInList = m_TechTreeNodes.GetNext( pos );
		if( pTechTreeNodeInList->m_strTechName == strTechDesc )
		{
			return pTechTreeNodeInList;
		}
	}
	return NULL;
}

CAnalysisUnitTemplateList* CUnitset::GetAnalysisUnitTemplateList( CString strName )
{
	POSITION pos = m_AnalysisList.GetHeadPosition();
	while( pos )
	{
		CAnalysisUnitTemplateList* pAnalysisUnitTemplateList = m_AnalysisList.GetNext( pos );
		if( pAnalysisUnitTemplateList->m_strName == strName )
		{
			return pAnalysisUnitTemplateList;
		}
	}
	return NULL;
}

float CUnitset::GetResearchPoints( long iDollars )
{
	// 0=2; 1=3; 2=4; 3=4.5; 4=5; 5=5.33; 6=5.66; 7=6; +=0.25

	// 2, 3, 4, 4.5, 5, 5.33, 5.66, 6; 0.25
	// 2, 1, 1, 0.5,0.5, 0.33,0.33,0.33, 0.25

	// 0 dollars = 2 research
	// 1 dollars = 3 research
	// 2 dollars = 4 research
	// 3 dollars = 4.5 research
	// 4 dollars = 5 research
	// 5 dollars = 5.33 research
	// 6 dollars = 5.66 research
	// 7 dollars = 6 research
	float fDollars = iDollars;
	CWorldBuildDesc* pWorldBuildDesc = GetCommonState()->GetWorldBuildDesc();
	/*
	if( pWorldBuildDesc )
	{
		fDollars *= pWorldBuildDesc->GetResearchRateMultiplier();
	}
	*/

	CMathFunction  ResearchMathFunction;
	ResearchMathFunction.SetInputOutput(  0.0f, 2.0f );
	ResearchMathFunction.SetInputOutput(  1.0f, 3.0f ); // +1
	ResearchMathFunction.SetInputOutput(  2.0f, 3.8f ); // +0.8
	ResearchMathFunction.SetInputOutput(  3.0f, 4.5f ); // +0.7
	ResearchMathFunction.SetInputOutput(  4.0f, 5.1f ); // +0.6
	ResearchMathFunction.SetInputOutput(  5.0f, 5.6f ); // +0.5
	ResearchMathFunction.SetInputOutput(  6.0f, 6.0f ); // +0.4
	ResearchMathFunction.SetInputOutput(  7.0f, 6.3f ); // +0.3
	ResearchMathFunction.SetInputOutput(  8.0f, 6.55f );// +0.25
	ResearchMathFunction.SetInputOutput(  9.0f, 6.80f );// +0.25
	ResearchMathFunction.SetInputOutput( 10.0f, 7.00f );// +0.2
	ResearchMathFunction.SetInputOutput( 11.0f, 7.20f );// +0.2
	ResearchMathFunction.SetInputOutput( 12.0f, 7.40f );// +0.2
	ResearchMathFunction.SetInputOutput( 13.0f, 7.60f );// +0.2
	ResearchMathFunction.SetInputOutput( 14.0f, 7.80f );// +0.2
	ResearchMathFunction.SetInputOutput( 15.0f, 8.00f );// +0.2
	ResearchMathFunction.SetInputOutput( 16.0f, 8.15f );// +0.15
	ResearchMathFunction.SetInputOutput( 17.0f, 8.30f );// +0.15
	ResearchMathFunction.SetInputOutput( 18.0f, 8.45f );// +0.15
	ResearchMathFunction.SetInputOutput( 19.0f, 8.60f );// +0.15
	ResearchMathFunction.SetInputOutput( 20.0f, 8.75f );// +0.15
	ResearchMathFunction.SetInputOutput( 21.0f, 8.90f );// +0.15
	ResearchMathFunction.SetInputOutput( 21.0f+100.0f, 8.90f+(100.0f*0.1f) );
	ResearchMathFunction.SetInputOutput( (21.0f+100.0f)+400.0f, 8.90f+(100.0f*0.1f)+(400.0f*0.05f)+0.01f );
	float fResearch = ResearchMathFunction.GetOutput( fDollars );
	if( pWorldBuildDesc )
	{
		fResearch *= pWorldBuildDesc->GetResearchRateMultiplier();
	}
	return fResearch;
	//return ResearchMathFunction.GetOutput( fDollars );
/*
	if( iDollars == 0 ){ return 2.0f; }
	if( iDollars == 1 ){ return 3.0f; }
	if( iDollars == 2 ){ return 4.0f; }
	if( iDollars == 3 ){ return 4.5f; }
	if( iDollars == 4 ){ return 5.0f; }
	if( iDollars == 5 ){ return 5.4f; }
	if( iDollars == 6 ){ return 5.7f; }
	if( iDollars == 7 ){ return 6.0f; }
	if( iDollars == 8 ){ return 6.25f; }
	if( iDollars == 9 ){ return 6.50f; }
	if( iDollars == 10 ){ return 6.75f; }
	if( iDollars == 11 ){ return 7.00f; }

	if( iDollars == 12 ){ return 7.20f; }
	if( iDollars == 13 ){ return 7.40f; }
	if( iDollars == 14 ){ return 7.60f; }
	if( iDollars == 15 ){ return 7.80f; }
	if( iDollars == 16 ){ return 8.00f; }
	if( iDollars == 17 ){ return 8.15f; }
	if( iDollars == 18 ){ return 8.30f; }
	if( iDollars == 19 ){ return 8.45f; }
	if( iDollars == 20 ){ return 8.60f; }
	iDollars -= 20;
	return 8.60f + 0.1f*((float)iDollars);
*/
	//return 4.25f + ((float)iDollars)/4.0f;  // 8 = 6.25, each additional point = 0.25 research
}

long  CUnitset::GetSpendingRequiredForXResearchPoints( float fResearchPoints )
{
	for( long iDollars=0; iDollars<100; iDollars++ )
	{
		float fVal = GetResearchPoints( iDollars );
		if( fVal >= fResearchPoints ) return iDollars;
	}
	return 100;
}

// Combat Experience

bool CUnitset::UseCombatExperience()
{
	if( m_fCombatLevelExperience[1] > 0.0f ||
		m_fCombatLevelExperience[2] > 0.0f ||
		m_fCombatLevelExperience[3] > 0.0f )
	{
		return true;
	}
	return false;
}

long CUnitset::GetCombatLevel( float fCombatExperience )
{
	// Raw, Green, Veteran, Crack
	if(  fCombatExperience < m_fCombatLevelExperience[1] ) return 0;
	eif( fCombatExperience < m_fCombatLevelExperience[2] ) return 1;
	eif( fCombatExperience < m_fCombatLevelExperience[3] ) return 2;
	return 3;
}

float CUnitset::GetCombatMultiplierFromExperience( float fCombatExperience )
{
	long iCombatLevel = GetCombatLevel( fCombatExperience );
	ASSERT( iCombatLevel >= 0 && iCombatLevel <= 3 );
	if( iCombatLevel < 0 ){ iCombatLevel = 0; }
	if( iCombatLevel > 3 ){ iCombatLevel = 3; }
	return GetCombatLevelMultiplier( iCombatLevel );
}

void CUnitset::SetCombatLevelExperience( long iCombatLevel, float fCombatExperience )
{
	ASSERT( iCombatLevel >= 0 && iCombatLevel <= 3 );
	if( iCombatLevel < 0 ){ iCombatLevel = 0; }
	if( iCombatLevel > 3 ){ iCombatLevel = 3; }
	m_fCombatLevelExperience[iCombatLevel] = fCombatExperience;
}

void CUnitset::SetCombatLevelMultiplier( long iCombatLevel, float fCombatMultiplier )
{
	ASSERT( iCombatLevel >= 0 && iCombatLevel <= 3 );
	if( iCombatLevel < 0 ){ iCombatLevel = 0; }
	if( iCombatLevel > 3 ){ iCombatLevel = 3; }
	m_fCombatLevelMultiplier[iCombatLevel] = fCombatMultiplier;
}

void CUnitset::SetCombatLevelName( long iCombatLevel, CString strText )
{
	ASSERT( iCombatLevel >= 0 && iCombatLevel <= 3 );
	if( iCombatLevel < 0 ){ iCombatLevel = 0; }
	if( iCombatLevel > 3 ){ iCombatLevel = 3; }
	m_strCombatLevelName[iCombatLevel] = strText;
}

/*
void  CUnitset::SetCombatExperience( long iCombatLevel, float fCombatExperience, float fCombatMult, CString strText )
{
	ASSERT( iCombatLevel >= 0 && iCombatLevel <= 3 );
	if( iCombatLevel < 0 ){ iCombatLevel = 0; }
	if( iCombatLevel > 3 ){ iCombatLevel = 3; }
	m_fLevelCombatExperience[iCombatLevel] = fCombatExperience;
	m_fLevelCombatMultiplier[iCombatLevel] = fCombatMult;
	m_strLevelCombatName[iCombatLevel] = strText;
}
*/
float  CUnitset::GetCombatLevelExperience( long iCombatLevel )
{
	ASSERT( iCombatLevel >= 0 && iCombatLevel <= 3 );
	return m_fCombatLevelExperience[iCombatLevel];
}

float  CUnitset::GetCombatLevelMultiplier( long iCombatLevel )
{
	ASSERT( iCombatLevel >= 0 && iCombatLevel <= 3 );
	return m_fCombatLevelMultiplier[iCombatLevel];
}

CString CUnitset::GetCombatLevelName( long iCombatLevel )
{
	ASSERT( iCombatLevel >= 0 && iCombatLevel <= 3 );
	return m_strCombatLevelName[iCombatLevel];
}


void  CUnitset::InvokeCityViewRange( CString strUnitTag, float fViewRange )
{
	POSITION pos = m_CityViewRangeList.GetHeadPosition();
	while( pos )
	{
		CViewRange* pViewRange = m_CityViewRangeList.GetNext( pos );
		if( pViewRange->m_strUnitTag == strUnitTag )
		{
			pViewRange->m_fViewRange = fViewRange;
			return;
		}
	}
	CViewRange* pViewRange = new CViewRange();
	pViewRange->m_strUnitTag = strUnitTag;
	pViewRange->m_fViewRange = fViewRange;
	m_CityViewRangeList.AddTail( pViewRange );
}

void CUnitset::RemoveCityViewRange( CString strUnitTag )
{
	POSITION pos = m_CityViewRangeList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CViewRange* pViewRange = m_CityViewRangeList.GetNext( pos );
		if( pViewRange->m_strUnitTag == strUnitTag )
		{
			m_CityViewRangeList.RemoveAt( prevPos );
		}
	}
}

void  CUnitset::InvokeResourceViewRange( CString strUnitTag, float fViewRange )
{
	POSITION pos = m_ResourceViewRangeList.GetHeadPosition();
	while( pos )
	{
		CViewRange* pViewRange = m_ResourceViewRangeList.GetNext( pos );
		if( pViewRange->m_strUnitTag == strUnitTag )
		{
			pViewRange->m_fViewRange = fViewRange;
			return;
		}
	}
	CViewRange* pViewRange = new CViewRange();
	pViewRange->m_strUnitTag = strUnitTag;
	pViewRange->m_fViewRange = fViewRange;
	m_ResourceViewRangeList.AddTail( pViewRange );
}

void CUnitset::RemoveResourceViewRange( CString strUnitTag )
{
	POSITION pos = m_ResourceViewRangeList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CViewRange* pViewRange = m_ResourceViewRangeList.GetNext( pos );
		if( pViewRange->m_strUnitTag == strUnitTag )
		{
			m_ResourceViewRangeList.RemoveAt( prevPos );
		}
	}
}

//

void   CUnitset::InvokeAirfieldConstructionCost( CString strResource, float fValue )
{
	if( fValue < 0.0f ){ fValue = 0.0f; }
	POSITION pos = m_AirfieldConstructionCostList.GetHeadPosition();
	while( pos )
	{
		CStringAndFloat* p = m_AirfieldConstructionCostList.GetNext( pos );
		if( p->m_strValue == strResource )
		{
			p->m_fValue = fValue;
			return;
		}
	}
	CStringAndFloat* p = new CStringAndFloat( strResource, fValue );
	m_AirfieldConstructionCostList.AddTail( p );
}

void   CUnitset::RemoveAirfieldConstructionCost( CString strResource )
{
	POSITION pos = m_AirfieldConstructionCostList.GetHeadPosition();
	while( pos )
	{
		POSITION prev = pos;
		CStringAndFloat* p = m_AirfieldConstructionCostList.GetNext( pos );
		if( p->m_strValue == strResource )
		{
			m_AirfieldConstructionCostList.RemoveAt( prev );
			delete p;
			return;
		}
	}
}

float  CUnitset::GetAirfieldConstructionCost( CString strResource )
{
	POSITION pos = m_AirfieldConstructionCostList.GetHeadPosition();
	while( pos )
	{
		POSITION prev = pos;
		CStringAndFloat* p = m_AirfieldConstructionCostList.GetNext( pos );
		if( p->m_strValue == strResource )
		{
			return p->m_fValue;
		}
	}
	return 0.0f;
}

CStringAndFloat*  CUnitset::GetAirfieldConstructionCostObj( CString strResource )
{
	POSITION pos = m_AirfieldConstructionCostList.GetHeadPosition();
	while( pos )
	{
		POSITION prev = pos;
		CStringAndFloat* p = m_AirfieldConstructionCostList.GetNext( pos );
		if( p->m_strValue == strResource )
		{
			return p;
		}
	}
	return NULL;
}

//

void   CUnitset::InvokeAirfieldProductionConsumption( CString strResource, float fValue )
{
	if( fValue < 0.0f ){ fValue = 0.0f; }
	POSITION pos = m_AirfieldProductionConsumptionList.GetHeadPosition();
	while( pos )
	{
		CStringAndFloat* p = m_AirfieldProductionConsumptionList.GetNext( pos );
		if( p->m_strValue == strResource )
		{
			p->m_fValue = fValue;
			return;
		}
	}
	CStringAndFloat* p = new CStringAndFloat( strResource, fValue );
	m_AirfieldProductionConsumptionList.AddTail( p );
}

void   CUnitset::RemoveAirfieldProductionConsumption( CString strResource )
{
	POSITION pos = m_AirfieldProductionConsumptionList.GetHeadPosition();
	while( pos )
	{
		POSITION prev = pos;
		CStringAndFloat* p = m_AirfieldProductionConsumptionList.GetNext( pos );
		if( p->m_strValue == strResource )
		{
			m_AirfieldProductionConsumptionList.RemoveAt( prev );
			delete p;
			return;
		}
	}
}

float  CUnitset::GetAirfieldProductionConsumption( CString strResource )
{
	POSITION pos = m_AirfieldProductionConsumptionList.GetHeadPosition();
	while( pos )
	{
		POSITION prev = pos;
		CStringAndFloat* p = m_AirfieldProductionConsumptionList.GetNext( pos );
		if( p->m_strValue == strResource )
		{
			return p->m_fValue;
		}
	}
	return 0.0f;
}

CStringAndFloat*  CUnitset::GetAirfieldProductionConsumptionObj( CString strResource )
{
	POSITION pos = m_AirfieldProductionConsumptionList.GetHeadPosition();
	while( pos )
	{
		POSITION prev = pos;
		CStringAndFloat* p = m_AirfieldProductionConsumptionList.GetNext( pos );
		if( p->m_strValue == strResource )
		{
			return p;
		}
	}
	return NULL;
}


CViewRange*  CUnitset::GetAirfieldViewRangeObj( CString strUnitTag )
{
	POSITION pos = m_AirfieldViewRangeList.GetHeadPosition();
	while( pos )
	{
		CViewRange* pViewRange = m_AirfieldViewRangeList.GetNext( pos );
		if( pViewRange->m_strUnitTag == strUnitTag )
		{
			return pViewRange;
		}
	}
	return NULL;
}

void  CUnitset::InvokeAirfieldViewRange( CString strUnitTag, float fViewRange )
{
	POSITION pos = m_AirfieldViewRangeList.GetHeadPosition();
	while( pos )
	{
		CViewRange* pViewRange = m_AirfieldViewRangeList.GetNext( pos );
		if( pViewRange->m_strUnitTag == strUnitTag )
		{
			pViewRange->m_fViewRange = fViewRange;
			return;
		}
	}
	CViewRange* pViewRange = new CViewRange();
	pViewRange->m_strUnitTag = strUnitTag;
	pViewRange->m_fViewRange = fViewRange;
	m_AirfieldViewRangeList.AddTail( pViewRange );
}

void CUnitset::RemoveAirfieldViewRange( CString strUnitTag )
{
	POSITION pos = m_AirfieldViewRangeList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CViewRange* pViewRange = m_AirfieldViewRangeList.GetNext( pos );
		if( pViewRange->m_strUnitTag == strUnitTag )
		{
			m_AirfieldViewRangeList.RemoveAt( prevPos );
		}
	}
}

void  CUnitset::InvokeUnitDefaultViewRange( CString strUnitTag, float fViewRange )
{
	POSITION pos = m_UnitDefaultViewRangeList.GetHeadPosition();
	while( pos )
	{
		CViewRange* pViewRange = m_UnitDefaultViewRangeList.GetNext( pos );
		if( pViewRange->m_strUnitTag == strUnitTag )
		{
			pViewRange->m_fViewRange = fViewRange;
			return;
		}
	}
	CViewRange* pViewRange = new CViewRange();
	pViewRange->m_strUnitTag = strUnitTag;
	pViewRange->m_fViewRange = fViewRange;
	m_UnitDefaultViewRangeList.AddTail( pViewRange );
}

void CUnitset::RemoveUnitDefaultViewRange( CString strUnitTag )
{
	POSITION pos = m_UnitDefaultViewRangeList.GetHeadPosition();
	while( pos )
	{
		POSITION prevPos = pos;
		CViewRange* pViewRange = m_UnitDefaultViewRangeList.GetNext( pos );
		if( pViewRange->m_strUnitTag == strUnitTag )
		{
			m_UnitDefaultViewRangeList.RemoveAt( prevPos );
		}
	}
}
